<?xml version="1.0" encoding="utf-8"?>
<feed xmlns="http://www.w3.org/2005/Atom">
  <title>七月のBlog</title>
  
  
  <link href="https://my-zhb.github.io/atom.xml" rel="self"/>
  
  <link href="https://my-zhb.github.io/"/>
  <updated>2021-01-04T14:08:08.533Z</updated>
  <id>https://my-zhb.github.io/</id>
  
  <author>
    <name>七月</name>
    
  </author>
  
  <generator uri="https://hexo.io/">Hexo</generator>
  
  <entry>
    <title>juc</title>
    <link href="https://my-zhb.github.io/2021/01/04/3cf22ab5.html"/>
    <id>https://my-zhb.github.io/2021/01/04/3cf22ab5.html</id>
    <published>2021-01-04T14:06:33.000Z</published>
    <updated>2021-01-04T14:08:08.533Z</updated>
    
    <content type="html"><![CDATA[<h1 id="什么是JUC"><a href="#什么是JUC" class="headerlink" title="什么是JUC"></a>什么是JUC</h1><p>java.util.concurrent在并发编程中使用的工具类</p><h1 id="线程和进程"><a href="#线程和进程" class="headerlink" title="线程和进程"></a>线程和进程</h1><p>进程是要给应用程序。<br>线程是一个进程中的一个执行单元。<br>一个进程可以有多个线程。  </p><h1 id="Synchronized和Lock区别"><a href="#Synchronized和Lock区别" class="headerlink" title="Synchronized和Lock区别"></a>Synchronized和Lock区别</h1><ol><li>Synchronized内置的Java关键字，Lock是一个Java类</li><li>Synchronized无法判断获取锁的状态，Lock 可以判断是否获取到锁</li><li>Synchronized会自动释放锁，Lock必须手动释放锁！如果没有释放锁会造成<code>死锁 </code></li><li>Synchronized 线程1(获得锁，阻塞)，线程2(一直等待)，Lock锁就不会一直等待。</li><li>Synchronized可重入锁，不可以中断的，非公平；Lock可重入锁，可以判断锁，非公平（可以自己设置，默认非公平）</li><li>Synchronized适合锁少量的代码同步问题，Lock适合锁大量的同步代码块。</li></ol><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="comment">//简单的Lock代码</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">User</span> </span>&#123;</span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">int</span> num = <span class="number">50</span>;</span><br><span class="line">    Lock lock = <span class="keyword">new</span> ReentrantLock();<span class="comment">//默认不公平锁 true 公平  false 不公平</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">sava</span><span class="params">(String name)</span></span>&#123;</span><br><span class="line">        lock.lock();</span><br><span class="line">        <span class="keyword">try</span> &#123;</span><br><span class="line">            <span class="keyword">if</span>(num&gt;<span class="number">0</span>)&#123;</span><br><span class="line">                System.out.println(name+<span class="string">&quot; 购买了,当前剩余数量：&quot;</span>+(num--));</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;<span class="keyword">catch</span> (Exception e)&#123;</span><br><span class="line">            e.getMessage();</span><br><span class="line">        &#125;<span class="keyword">finally</span> &#123;</span><br><span class="line">            lock.unlock();</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">int</span> <span class="title">getNum</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> num;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">setNum</span><span class="params">(<span class="keyword">int</span> num)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">this</span>.num = num;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">//测试</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line">        User user = <span class="keyword">new</span> User();</span><br><span class="line">        <span class="keyword">new</span> Thread(() -&gt; &#123;</span><br><span class="line">            <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; <span class="number">60</span>; i++) &#123;</span><br><span class="line">                user.sava(<span class="string">&quot;小王&quot;</span>);</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;).start();</span><br><span class="line"></span><br><span class="line">        <span class="keyword">new</span> Thread(() -&gt; &#123;</span><br><span class="line">            <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; <span class="number">60</span>; i++) &#123;</span><br><span class="line">                user.sava(<span class="string">&quot;小李&quot;</span>);</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;).start();</span><br><span class="line"></span><br><span class="line">        <span class="keyword">new</span> Thread(() -&gt; &#123;</span><br><span class="line">            <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; <span class="number">60</span>; i++) &#123;</span><br><span class="line">                user.sava(<span class="string">&quot;小猪&quot;</span>);</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;).start();</span><br><span class="line">    &#125;</span><br><span class="line"><span class="comment">//结果</span></span><br><span class="line">小王 购买了,当前剩余数量：<span class="number">50</span></span><br><span class="line">小猪 购买了,当前剩余数量：<span class="number">49</span></span><br><span class="line">小猪 购买了,当前剩余数量：<span class="number">48</span></span><br><span class="line">小猪 购买了,当前剩余数量：<span class="number">47</span></span><br><span class="line">小猪 购买了,当前剩余数量：<span class="number">46</span></span><br><span class="line">......</span><br></pre></td></tr></table></figure><h1 id="生产者和消费者问题"><a href="#生产者和消费者问题" class="headerlink" title="生产者和消费者问题"></a>生产者和消费者问题</h1><blockquote><p>synchronized版本（以下代码还是存在线程安全问题）</p></blockquote><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Test</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line">        Data data = <span class="keyword">new</span> Data();</span><br><span class="line">        <span class="keyword">new</span> Thread(() -&gt; &#123;</span><br><span class="line">            <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt;<span class="number">10</span> ; i++) &#123;</span><br><span class="line">                <span class="keyword">try</span> &#123;</span><br><span class="line">                    data.increment();</span><br><span class="line">                &#125; <span class="keyword">catch</span> (Exception e) &#123;</span><br><span class="line">                    e.printStackTrace();</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;,<span class="string">&quot;A&quot;</span>).start();</span><br><span class="line">        <span class="keyword">new</span> Thread(() -&gt; &#123;</span><br><span class="line">            <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt;<span class="number">10</span> ; i++) &#123;</span><br><span class="line">                <span class="keyword">try</span> &#123;</span><br><span class="line">                    data.decrement();</span><br><span class="line">                &#125; <span class="keyword">catch</span> (Exception e) &#123;</span><br><span class="line">                    e.printStackTrace();</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;,<span class="string">&quot;B&quot;</span>).start();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">//判断等待，业务，通知</span></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Data</span></span>&#123;</span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">int</span> number = <span class="number">0</span>;</span><br><span class="line">    <span class="comment">//+1</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">synchronized</span> <span class="keyword">void</span> <span class="title">increment</span><span class="params">()</span> <span class="keyword">throws</span> Exception</span>&#123;</span><br><span class="line">        <span class="keyword">if</span>(number != <span class="number">0</span>)&#123;</span><br><span class="line">            <span class="comment">//等待</span></span><br><span class="line">            <span class="keyword">this</span>.wait();</span><br><span class="line">        &#125;</span><br><span class="line">        number ++ ;</span><br><span class="line">        System.out.println(Thread.currentThread().getName()+<span class="string">&quot;==&gt;&gt;&quot;</span>+number);</span><br><span class="line">        <span class="comment">//通知其他线程我加完了</span></span><br><span class="line">        <span class="keyword">this</span>.notify();</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">//-1</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">synchronized</span> <span class="keyword">void</span> <span class="title">decrement</span><span class="params">()</span> <span class="keyword">throws</span> Exception</span>&#123;</span><br><span class="line">        <span class="keyword">if</span>(number == <span class="number">0</span>)&#123;</span><br><span class="line">            <span class="comment">//等待</span></span><br><span class="line">            <span class="keyword">this</span>.wait();</span><br><span class="line">        &#125;</span><br><span class="line">        number--;</span><br><span class="line">        System.out.println(Thread.currentThread().getName()+<span class="string">&quot;==&gt;&gt;&quot;</span>+number);</span><br><span class="line">        <span class="comment">//通知其他线程我减完了</span></span><br><span class="line">        <span class="keyword">this</span>.notifyAll();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><blockquote><p>以上代码在只要2个线程（A,B）的情况不会出现问题，如果在加（C,D）两个线程会出现是问题</p></blockquote><figure class="highlight java"><table><tr><td class="code"><pre><span class="line">A==&gt;&gt;<span class="number">6</span></span><br><span class="line">C==&gt;&gt;<span class="number">7</span></span><br><span class="line">A==&gt;&gt;<span class="number">8</span></span><br><span class="line">D==&gt;&gt;<span class="number">7</span></span><br><span class="line">C==&gt;&gt;<span class="number">8</span></span><br></pre></td></tr></table></figure><p><code>线程也可以被唤醒，而不会被通知，中断或者超时，这种情况被称为虚假唤醒，所以这里应该把if判断改为while循环</code></p><p><code>因为if判断只判断一次，而while判断会等待</code></p><p><img src= "/img/loading.gif" data-lazy-src="https://cdn.jsdelivr.net/gh/my-zhb/CDN/img/20201214171351.png" alt="img"></p><blockquote><p>Lock版本（其中lock替代synchronized ，Condition取代了对象监视器）</p></blockquote><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Test</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line">        Data data = <span class="keyword">new</span> Data();</span><br><span class="line">        <span class="keyword">new</span> Thread(() -&gt; &#123;</span><br><span class="line">            <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt;<span class="number">10</span> ; i++) &#123;</span><br><span class="line">                data.increment();</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;,<span class="string">&quot;A&quot;</span>).start();</span><br><span class="line">        <span class="keyword">new</span> Thread(() -&gt; &#123;</span><br><span class="line">            <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt;<span class="number">10</span> ; i++) &#123;</span><br><span class="line">                data.decrement();</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;,<span class="string">&quot;B&quot;</span>).start();</span><br><span class="line">        <span class="keyword">new</span> Thread(() -&gt; &#123;</span><br><span class="line">            <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt;<span class="number">10</span> ; i++) &#123;</span><br><span class="line">                data.increment();</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;,<span class="string">&quot;C&quot;</span>).start();</span><br><span class="line">        <span class="keyword">new</span> Thread(() -&gt; &#123;</span><br><span class="line">            <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt;<span class="number">10</span> ; i++) &#123;</span><br><span class="line">                data.decrement();</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;,<span class="string">&quot;D&quot;</span>).start();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">//判断等待，业务，通知</span></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Data</span></span>&#123;</span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">int</span> number = <span class="number">0</span>;</span><br><span class="line">    <span class="comment">//创建lock锁（lock替代了synchronized）</span></span><br><span class="line">    Lock lock = <span class="keyword">new</span> ReentrantLock();</span><br><span class="line">    <span class="comment">//创建监视器（Condition替代了同步监视器）</span></span><br><span class="line">    Condition condition = lock.newCondition();</span><br><span class="line"></span><br><span class="line">    <span class="comment">//+1</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span>  <span class="keyword">void</span> <span class="title">increment</span><span class="params">()</span></span>&#123;</span><br><span class="line">        lock.lock();</span><br><span class="line">        <span class="keyword">try</span> &#123;</span><br><span class="line">            <span class="keyword">while</span> (number != <span class="number">0</span>)&#123;</span><br><span class="line">                <span class="comment">//等待</span></span><br><span class="line">                condition.await();</span><br><span class="line">            &#125;</span><br><span class="line">            number ++ ;</span><br><span class="line">            System.out.println(Thread.currentThread().getName()+<span class="string">&quot;==&gt;&gt;&quot;</span>+number);</span><br><span class="line">            <span class="comment">//通知其他线程我加完了</span></span><br><span class="line">            condition.signalAll();</span><br><span class="line">        &#125;<span class="keyword">catch</span> (Exception e)&#123;</span><br><span class="line">            e.getMessage();</span><br><span class="line">        &#125;<span class="keyword">finally</span> &#123;</span><br><span class="line">            <span class="comment">//必须关闭不然会出现死锁</span></span><br><span class="line">            lock.unlock();</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">//-1</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span>  <span class="keyword">void</span> <span class="title">decrement</span><span class="params">()</span></span>&#123;</span><br><span class="line">        lock.lock();</span><br><span class="line">        <span class="keyword">try</span> &#123;</span><br><span class="line">            <span class="keyword">while</span> (number == <span class="number">0</span>)&#123;</span><br><span class="line">                <span class="comment">//等待</span></span><br><span class="line">                condition.await();</span><br><span class="line">            &#125;</span><br><span class="line">            number -- ;</span><br><span class="line">            System.out.println(Thread.currentThread().getName()+<span class="string">&quot;==&gt;&gt;&quot;</span>+number);</span><br><span class="line">            <span class="comment">//通知其他线程我加完了</span></span><br><span class="line">            condition.signalAll();</span><br><span class="line">        &#125;<span class="keyword">catch</span> (Exception e)&#123;</span><br><span class="line">            e.getMessage();</span><br><span class="line">        &#125;<span class="keyword">finally</span> &#123;</span><br><span class="line">            lock.unlock();</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><blockquote><p>Condition 如何精准的通知和唤醒线程（A-&gt;B-&gt;C-&gt;D）</p></blockquote><p>通过创建多个Condition 来实现精准的通知和唤醒</p><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Test</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line">        Data data = <span class="keyword">new</span> Data();</span><br><span class="line">        <span class="keyword">new</span> Thread(() -&gt; &#123;</span><br><span class="line">            <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt;<span class="number">10</span> ; i++) &#123;</span><br><span class="line">                data.condition1();</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;,<span class="string">&quot;A&quot;</span>).start();</span><br><span class="line">        <span class="keyword">new</span> Thread(() -&gt; &#123;</span><br><span class="line">            <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt;<span class="number">10</span> ; i++) &#123;</span><br><span class="line">                data.condition2();</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;,<span class="string">&quot;B&quot;</span>).start();</span><br><span class="line">        <span class="keyword">new</span> Thread(() -&gt; &#123;</span><br><span class="line">            <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt;<span class="number">10</span> ; i++) &#123;</span><br><span class="line">                data.condition3();</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;,<span class="string">&quot;C&quot;</span>).start();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Data</span></span>&#123;</span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">int</span> number = <span class="number">1</span>;</span><br><span class="line"></span><br><span class="line">    Lock lock = <span class="keyword">new</span> ReentrantLock();</span><br><span class="line">    Condition condition1 = lock.newCondition();</span><br><span class="line">    Condition condition2 = lock.newCondition();</span><br><span class="line">    Condition condition3 = lock.newCondition();</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">condition1</span><span class="params">()</span></span>&#123;</span><br><span class="line">        lock.lock();</span><br><span class="line">        <span class="keyword">try</span> &#123;</span><br><span class="line">            <span class="keyword">while</span> (number!=<span class="number">1</span>)&#123;</span><br><span class="line">                condition1.await();</span><br><span class="line">            &#125;</span><br><span class="line">            number++;</span><br><span class="line">            System.out.println(Thread.currentThread().getName()+<span class="string">&quot;===&gt;&gt;&gt;AAAAA&quot;</span>);</span><br><span class="line">            condition2.signal();</span><br><span class="line">        &#125; <span class="keyword">catch</span> (InterruptedException e) &#123;</span><br><span class="line">            e.printStackTrace();</span><br><span class="line">        &#125;<span class="keyword">finally</span> &#123;</span><br><span class="line">            lock.unlock();</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">condition2</span><span class="params">()</span></span>&#123;</span><br><span class="line">        lock.lock();</span><br><span class="line">        <span class="keyword">try</span> &#123;</span><br><span class="line">            <span class="keyword">while</span> (number!=<span class="number">2</span>)&#123;</span><br><span class="line">                condition2.await();</span><br><span class="line">            &#125;</span><br><span class="line">            number++;</span><br><span class="line">            System.out.println(Thread.currentThread().getName()+<span class="string">&quot;===&gt;&gt;&gt;BBBBB&quot;</span>);</span><br><span class="line">            condition3.signal();</span><br><span class="line">        &#125; <span class="keyword">catch</span> (InterruptedException e) &#123;</span><br><span class="line">            e.printStackTrace();</span><br><span class="line">        &#125;<span class="keyword">finally</span> &#123;</span><br><span class="line">            lock.unlock();</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">condition3</span><span class="params">()</span></span>&#123;</span><br><span class="line">        lock.lock();</span><br><span class="line">        <span class="keyword">try</span> &#123;</span><br><span class="line">            <span class="keyword">while</span> (number!=<span class="number">3</span>)&#123;</span><br><span class="line">                condition3.await();</span><br><span class="line">            &#125;</span><br><span class="line">            number=<span class="number">1</span>;</span><br><span class="line">            System.out.println(Thread.currentThread().getName()+<span class="string">&quot;===&gt;&gt;&gt;CCCCC&quot;</span>);</span><br><span class="line">            condition1.signal();</span><br><span class="line">        &#125; <span class="keyword">catch</span> (InterruptedException e) &#123;</span><br><span class="line">            e.printStackTrace();</span><br><span class="line">        &#125;<span class="keyword">finally</span> &#123;</span><br><span class="line">            lock.unlock();</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h1 id="8锁现象"><a href="#8锁现象" class="headerlink" title="8锁现象"></a>8锁现象</h1><blockquote><p>此处synchronized锁的是方法的调用者，sendSms()和call()两个方法用的是同一把锁,谁先拿到谁先执行</p></blockquote><p><code>TimeUnit.SECONDS.sleep(1)不管放在方法里还是线程A和线程B之间 它的执行结果都是一样的</code></p><ol><li>一个对象，两个同步方法块，睡眠放在线程A和线程B之间</li></ol><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Test1</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line">        Phone phone = <span class="keyword">new</span> Phone();</span><br><span class="line">        <span class="keyword">new</span> Thread(() -&gt; &#123;</span><br><span class="line">            phone.sendSms();</span><br><span class="line">        &#125;,<span class="string">&quot;A&quot;</span>).start();</span><br><span class="line">        <span class="keyword">try</span> &#123;</span><br><span class="line">            TimeUnit.SECONDS.sleep(<span class="number">4</span>);</span><br><span class="line">        &#125; <span class="keyword">catch</span> (InterruptedException e) &#123;</span><br><span class="line">            e.printStackTrace();</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">new</span> Thread(() -&gt; &#123;</span><br><span class="line">            phone.call();</span><br><span class="line">        &#125;,<span class="string">&quot;B&quot;</span>).start();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Phone</span></span>&#123;</span><br><span class="line">    <span class="comment">//synchronized 锁的是方法的调用者</span></span><br><span class="line">    <span class="comment">//两个方法用的是同一把锁,谁先拿到谁先执行</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">synchronized</span> <span class="keyword">void</span> <span class="title">sendSms</span><span class="params">()</span></span>&#123;</span><br><span class="line">        System.out.println(<span class="string">&quot;发短信&quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">synchronized</span> <span class="keyword">void</span> <span class="title">call</span><span class="params">()</span></span>&#123;</span><br><span class="line">        System.out.println(<span class="string">&quot;打电话&quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><ol start="2"><li>一个对象，两个同步方法块，睡眠放在同步方法里</li></ol><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Test1</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line">        Phone phone = <span class="keyword">new</span> Phone();</span><br><span class="line">        <span class="keyword">new</span> Thread(() -&gt; &#123;</span><br><span class="line">            phone.sendSms();</span><br><span class="line">        &#125;,<span class="string">&quot;A&quot;</span>).start();</span><br><span class="line">        <span class="keyword">try</span> &#123;</span><br><span class="line">            TimeUnit.SECONDS.sleep(<span class="number">1</span>);</span><br><span class="line">        &#125; <span class="keyword">catch</span> (InterruptedException e) &#123;</span><br><span class="line">            e.printStackTrace();</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">new</span> Thread(() -&gt; &#123;</span><br><span class="line">            phone.call();</span><br><span class="line">        &#125;,<span class="string">&quot;B&quot;</span>).start();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Phone</span></span>&#123;</span><br><span class="line">    <span class="comment">//synchronized 锁的是方法的调用者</span></span><br><span class="line">    <span class="comment">//两个方法用的是同一把锁,谁先拿到谁先执行</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">synchronized</span> <span class="keyword">void</span> <span class="title">sendSms</span><span class="params">()</span></span>&#123;</span><br><span class="line">        <span class="keyword">try</span> &#123;</span><br><span class="line">            TimeUnit.SECONDS.sleep(<span class="number">1</span>);</span><br><span class="line">        &#125; <span class="keyword">catch</span> (InterruptedException e) &#123;</span><br><span class="line">            e.printStackTrace();</span><br><span class="line">        &#125;</span><br><span class="line">        System.out.println(<span class="string">&quot;发短信&quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">synchronized</span> <span class="keyword">void</span> <span class="title">call</span><span class="params">()</span></span>&#123;</span><br><span class="line">        System.out.println(<span class="string">&quot;打电话&quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">//结果</span></span><br><span class="line">发短信</span><br><span class="line">打电话</span><br></pre></td></tr></table></figure><blockquote><p>hello()方法没有synchronized关键字，所以不受影响正常输出</p></blockquote><ol start="3"><li>一个对象，两个同步方法块，一个普通方法（随机）</li></ol><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Test2</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line">        Phone2 phone = <span class="keyword">new</span> Phone2();</span><br><span class="line">        <span class="keyword">new</span> Thread(() -&gt; &#123;</span><br><span class="line">            phone.sendSms();</span><br><span class="line">        &#125;,<span class="string">&quot;A&quot;</span>).start();</span><br><span class="line"></span><br><span class="line">        <span class="keyword">new</span> Thread(() -&gt; &#123;</span><br><span class="line">            phone.hello();</span><br><span class="line">        &#125;,<span class="string">&quot;B&quot;</span>).start();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Phone2</span></span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">synchronized</span> <span class="keyword">void</span> <span class="title">sendSms</span><span class="params">()</span></span>&#123;</span><br><span class="line">        System.out.println(<span class="string">&quot;发短信&quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">synchronized</span> <span class="keyword">void</span> <span class="title">call</span><span class="params">()</span></span>&#123;</span><br><span class="line">        System.out.println(<span class="string">&quot;打电话&quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">//hello没有synchronized关键字所以不受影响</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">hello</span><span class="params">()</span></span>&#123;</span><br><span class="line">        System.out.println(<span class="string">&quot;hello&quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><blockquote><p>因为是2个对象调用方法，锁的不是同一个对象，sendSms()睡了1秒，所以先输出打电话，在输出发短信，如果没有睡眠，就是随机的。</p></blockquote><ol start="4"><li>两个对象，两个同步方法块（随机）</li></ol><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Test2</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line">        Phone2 phone1 = <span class="keyword">new</span> Phone2();</span><br><span class="line">        Phone2 phone2 = <span class="keyword">new</span> Phone2();</span><br><span class="line">        <span class="keyword">new</span> Thread(() -&gt; &#123;</span><br><span class="line">            phone1.sendSms();</span><br><span class="line">        &#125;,<span class="string">&quot;A&quot;</span>).start();</span><br><span class="line"></span><br><span class="line">        <span class="keyword">new</span> Thread(() -&gt; &#123;</span><br><span class="line">            phone2.call();</span><br><span class="line">        &#125;,<span class="string">&quot;B&quot;</span>).start();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Phone2</span></span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">synchronized</span> <span class="keyword">void</span> <span class="title">sendSms</span><span class="params">()</span></span>&#123;</span><br><span class="line">        System.out.println(<span class="string">&quot;发短信&quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">synchronized</span> <span class="keyword">void</span> <span class="title">call</span><span class="params">()</span></span>&#123;</span><br><span class="line">        System.out.println(<span class="string">&quot;打电话&quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><blockquote><p>因为sendSms()和call()方法都是static修饰的，所以类一加载就有了，实际这里锁的是class模版</p></blockquote><ol start="5"><li>增加两个静态的同步方法，只有一个对象（先输出发短信）</li></ol><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Test3</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line">        Phone3 phone = <span class="keyword">new</span> Phone3();</span><br><span class="line">        <span class="keyword">new</span> Thread(() -&gt; &#123;</span><br><span class="line">            phone.sendSms();</span><br><span class="line">        &#125;,<span class="string">&quot;A&quot;</span>).start();</span><br><span class="line"></span><br><span class="line">        <span class="keyword">new</span> Thread(() -&gt; &#123;</span><br><span class="line">            phone.call();</span><br><span class="line">        &#125;,<span class="string">&quot;B&quot;</span>).start();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Phone3</span></span>&#123;</span><br><span class="line">    <span class="comment">//synchronized 锁的是对象</span></span><br><span class="line">    <span class="comment">//因为是static修饰的，所以类一加载就有了，实际这里锁的是class模版</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">synchronized</span> <span class="keyword">void</span> <span class="title">sendSms</span><span class="params">()</span></span>&#123;</span><br><span class="line">        System.out.println(<span class="string">&quot;发短信&quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">synchronized</span> <span class="keyword">void</span> <span class="title">call</span><span class="params">()</span></span>&#123;</span><br><span class="line">        System.out.println(<span class="string">&quot;打电话&quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><ol start="6"><li>两个对象，两个静态的同步方法 （随机）</li></ol><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Test3</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line">        Phone3 phone1 = <span class="keyword">new</span> Phone3();</span><br><span class="line">        Phone3 phone2 = <span class="keyword">new</span> Phone3();</span><br><span class="line">        <span class="keyword">new</span> Thread(() -&gt; &#123;</span><br><span class="line">            phone1.sendSms();</span><br><span class="line">        &#125;,<span class="string">&quot;A&quot;</span>).start();</span><br><span class="line"></span><br><span class="line">        <span class="keyword">new</span> Thread(() -&gt; &#123;</span><br><span class="line">            phone2.call();</span><br><span class="line">        &#125;,<span class="string">&quot;B&quot;</span>).start();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Phone3</span></span>&#123;</span><br><span class="line">    <span class="comment">//synchronized 锁的是对象</span></span><br><span class="line">    <span class="comment">//因为是static修饰的，所以类一加载就有了，实际这里锁的是class模版</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">synchronized</span> <span class="keyword">void</span> <span class="title">sendSms</span><span class="params">()</span></span>&#123;</span><br><span class="line">        System.out.println(<span class="string">&quot;发短信&quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">synchronized</span> <span class="keyword">void</span> <span class="title">call</span><span class="params">()</span></span>&#123;</span><br><span class="line">        System.out.println(<span class="string">&quot;打电话&quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><blockquote><p>如果同一个对象调用对象的一个非静态同步方法与同步方法，此时会出现两把锁，一个是类锁，一个是对象调用者锁</p></blockquote><ol start="7"><li>一个静态的同步方法，一个非静态的同步方法（随机）</li></ol><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Test3</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line">        Phone3 phone = <span class="keyword">new</span> Phone3();</span><br><span class="line">        <span class="keyword">new</span> Thread(() -&gt; &#123;</span><br><span class="line">            phone.sendSms();</span><br><span class="line">        &#125;,<span class="string">&quot;A&quot;</span>).start();</span><br><span class="line"></span><br><span class="line">        <span class="keyword">new</span> Thread(() -&gt; &#123;</span><br><span class="line">            phone.call();</span><br><span class="line">        &#125;,<span class="string">&quot;B&quot;</span>).start();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Phone3</span></span>&#123;</span><br><span class="line">    <span class="comment">//static修饰的方法锁的实际上是class模版</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">synchronized</span> <span class="keyword">void</span> <span class="title">sendSms</span><span class="params">()</span>   </span>&#123;</span><br><span class="line">        System.out.println(<span class="string">&quot;发短信&quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">//正常情况下锁的是方法的调用者</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">synchronized</span> <span class="keyword">void</span> <span class="title">call</span><span class="params">()</span></span>&#123;</span><br><span class="line">        System.out.println(<span class="string">&quot;打电话&quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">//结果</span></span><br><span class="line">发短信</span><br><span class="line">打电话</span><br></pre></td></tr></table></figure><ol start="8"><li>两个不同的对象，一个静态同步方法块，一个非静态同步方法块（随机）</li></ol><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Test3</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line">        Phone3 phone1 = <span class="keyword">new</span> Phone3();</span><br><span class="line">        Phone3 phone2 = <span class="keyword">new</span> Phone3();</span><br><span class="line">        <span class="keyword">new</span> Thread(() -&gt; &#123;</span><br><span class="line">            phone1.sendSms();</span><br><span class="line">        &#125;,<span class="string">&quot;A&quot;</span>).start();</span><br><span class="line"></span><br><span class="line">        <span class="keyword">new</span> Thread(() -&gt; &#123;</span><br><span class="line">            phone2.call();</span><br><span class="line">        &#125;,<span class="string">&quot;B&quot;</span>).start();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Phone3</span></span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">synchronized</span> <span class="keyword">void</span> <span class="title">sendSms</span><span class="params">()</span>   </span>&#123;</span><br><span class="line">        System.out.println(<span class="string">&quot;发短信&quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">synchronized</span> <span class="keyword">void</span> <span class="title">call</span><span class="params">()</span></span>&#123;</span><br><span class="line">        System.out.println(<span class="string">&quot;打电话&quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">//结果</span></span><br><span class="line">结果随机</span><br></pre></td></tr></table></figure><blockquote><p>总结</p></blockquote><ol><li>new,this 具体的一个对象（对象锁）</li><li>static 唯一的（class锁，类锁）</li></ol><h1 id="集合类不安全"><a href="#集合类不安全" class="headerlink" title="集合类不安全"></a>集合类不安全</h1><blockquote><p>List</p></blockquote><p>并发情况下往ArrayList写入数据</p><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">ListTest</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line">        List&lt;String&gt; list = <span class="keyword">new</span> ArrayList&lt;&gt;();</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">1</span>; i &lt;= <span class="number">10</span> ; i++) &#123;</span><br><span class="line">            <span class="keyword">new</span> Thread(() -&gt; &#123;</span><br><span class="line">                list.add(UUID.randomUUID().toString().substring(<span class="number">0</span>,<span class="number">5</span>));</span><br><span class="line">                System.out.println(list);</span><br><span class="line">            &#125;,String.valueOf(i)).start();</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">//会出现 java.util.ConcurrentModificationException 并发修改异常</span></span><br></pre></td></tr></table></figure><p>解决方法</p><ol><li><code>List&lt;String&gt; list = new Vector&lt;&gt;()</code>不建议用，因为底层是synchronized修饰的效率低</li><li><code>List&lt;String&gt; list = Collections.synchronizedList(new ArrayList&lt;&gt;())</code></li><li><code>List&lt;String&gt; list = new CopyOnWriteArrayList&lt;&gt;();juc下面的CopyOnWriteArrayList方法</code><ol><li><code>CopyOnWrite</code> 写入时复制，简称COW 计算机设计领域的一种优化策略。</li><li>多个线程调用的时候，list读取的时候，固定的，写入会出现覆盖，所以写入数据前会先复制原有数据，避免造成数据问</li></ol></li></ol><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">ListTest</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line">        List&lt;String&gt; list = <span class="keyword">new</span> CopyOnWriteArrayList&lt;&gt;();</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">1</span>; i &lt;= <span class="number">10</span> ; i++) &#123;</span><br><span class="line">            <span class="keyword">new</span> Thread(() -&gt; &#123;</span><br><span class="line">                list.add(UUID.randomUUID().toString().substring(<span class="number">0</span>,<span class="number">5</span>));</span><br><span class="line">                System.out.println(list);</span><br><span class="line">            &#125;,String.valueOf(i)).start();</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><blockquote><p>Set (与list差不多)</p></blockquote><p>解决办法</p><ol><li><code>Collections.synchronizedSet(new HashSet&lt;&gt;())</code></li><li><code>Set&lt;String&gt; set = new CopyOnWriteArraySet&lt;&gt;()</code></li></ol><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">SetTest</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line">        Set&lt;String&gt; set = <span class="keyword">new</span> CopyOnWriteArraySet&lt;&gt;();</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">1</span>; i &lt;= <span class="number">10</span> ; i++) &#123;</span><br><span class="line">            <span class="keyword">new</span> Thread(() -&gt; &#123;</span><br><span class="line">                set.add(UUID.randomUUID().toString().substring(<span class="number">0</span>,<span class="number">5</span>));</span><br><span class="line">                System.out.println(set);</span><br><span class="line">            &#125;,String.valueOf(i)).start();</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><code>HashSet底层其实就是HashMap的key</code></p><blockquote><p>Map</p></blockquote><p>解决办法</p><ol><li><code>Collections.synchronizedMap(new HashMap&lt;&gt;())</code></li><li><code> Map&lt;String,String&gt; map = new ConcurrentHashMap&lt;&gt;()</code></li></ol><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">MapTest</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line">        Map&lt;String,String&gt; map = <span class="keyword">new</span> ConcurrentHashMap&lt;&gt;();</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">1</span>; i &lt;= <span class="number">100</span> ; i++) &#123;</span><br><span class="line">            <span class="keyword">new</span> Thread(() -&gt; &#123;</span><br><span class="line">                map.put(Thread.currentThread().getName(),UUID.randomUUID().toString().substring(<span class="number">0</span>,<span class="number">5</span>));</span><br><span class="line">                System.out.println(map);</span><br><span class="line">            &#125;,String.valueOf(i)).start();</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><code>Map默认的两个参数为加载因子0.75f，初始容量1&lt;&lt;4（16）</code></p><h1 id="Callable"><a href="#Callable" class="headerlink" title="Callable"></a>Callable</h1><h2 id="什么是Callable"><a href="#什么是Callable" class="headerlink" title="什么是Callable"></a>什么是Callable</h2><p><code>Callable</code>接口类似于<code>Runnable</code>，因为它们都是为其实例可能由另一个线程执行的类设计的。 然而，<code>Runnable</code>不返回结果，也不能抛出被检查的异常，<code>Callable</code>能返回结果也可以抛出异常。</p><h2 id="怎么启动Callable"><a href="#怎么启动Callable" class="headerlink" title="怎么启动Callable"></a>怎么启动Callable</h2><p>通过FutureTask，FutureTask的本质就是Runnable，因为Runnable实现了FutureTask</p><p>FutureTask.get()方法可能会造成阻塞，因为这里会去等待线程的执行，可以通过异步的方式解决</p><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Test</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> <span class="keyword">throws</span> ExecutionException, InterruptedException </span>&#123;</span><br><span class="line">        <span class="comment">//FutureTask的本质就是Runnable,FutureTask是一个适配器，来适配Callable</span></span><br><span class="line">        MyThread myThread = <span class="keyword">new</span> MyThread();</span><br><span class="line">        FutureTask myThreadFutureTask = <span class="keyword">new</span> FutureTask(myThread);</span><br><span class="line">        </span><br><span class="line">        <span class="keyword">new</span> Thread(myThreadFutureTask,<span class="string">&quot;A&quot;</span>).start();</span><br><span class="line">        <span class="comment">//这里会有缓存，所以执行结果之会输出一次</span></span><br><span class="line">        <span class="keyword">new</span> Thread(myThreadFutureTask,<span class="string">&quot;B&quot;</span>).start();</span><br><span class="line">        <span class="comment">//这里通过FutureTask.get()方法可以获取到Callable的返回值</span></span><br><span class="line">        Object o = myThreadFutureTask.get();</span><br><span class="line">        System.out.println(o);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">MyThread</span> <span class="keyword">implements</span> <span class="title">Callable</span>&lt;<span class="title">Integer</span>&gt; </span>&#123;</span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> Integer <span class="title">call</span><span class="params">()</span> <span class="keyword">throws</span> Exception </span>&#123;</span><br><span class="line">        System.out.println(<span class="string">&quot;call()&quot;</span>);</span><br><span class="line">        <span class="keyword">return</span> <span class="number">10</span>;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">//执行结果</span></span><br><span class="line">call()</span><br><span class="line"><span class="number">10</span></span><br></pre></td></tr></table></figure><h1 id="常用的辅助类"><a href="#常用的辅助类" class="headerlink" title="常用的辅助类"></a>常用的辅助类</h1><h2 id="CountDownLatch"><a href="#CountDownLatch" class="headerlink" title="CountDownLatch"></a>CountDownLatch</h2><p>定义：可以直接理解为一个减法计数器</p><p>用法：<code>CountDownLatch</code>用给定的<em>计数</em>初始化。 <code>await</code>方法阻塞，直到由于<code>countDown()</code>方法的调用而导致当前计数达到零，之后所有等待线程被释放，并且任何后续的<code>await</code>调用立即返回。这是一个一次性的现象 - 计数无法重置。 如果您需要重置计数的版本，请考虑使用<code>CyclicBarrier</code>。</p><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">CountDownLatchDemo</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> <span class="keyword">throws</span> InterruptedException </span>&#123;</span><br><span class="line">        CountDownLatch countDownLatch = <span class="keyword">new</span> CountDownLatch(<span class="number">3</span>);</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">1</span>; i &lt;=<span class="number">3</span> ; i++) &#123;</span><br><span class="line">            <span class="keyword">new</span> Thread(() -&gt; &#123;</span><br><span class="line">                <span class="comment">//-1操作</span></span><br><span class="line">                countDownLatch.countDown();</span><br><span class="line">                System.out.println(Thread.currentThread().getName()+<span class="string">&quot;出去了&quot;</span>);</span><br><span class="line">            &#125;,String.valueOf(i)).start();</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="comment">//阻塞，直到线程执行完毕</span></span><br><span class="line">        countDownLatch.await();</span><br><span class="line">        System.out.println(<span class="string">&quot;出去完了，可以关门了&quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">//执行结果</span></span><br><span class="line"><span class="number">1</span>出去了</span><br><span class="line"><span class="number">3</span>出去了</span><br><span class="line"><span class="number">2</span>出去了</span><br><span class="line">出去完了，可以关门了</span><br></pre></td></tr></table></figure><p>理解：</p><pre><code>` countDownLatch.countDown()`每次调用减1`countDownLatch.await()`等待计数器归零，然后才往下继续执行。</code></pre><h2 id="CyclicBarrier"><a href="#CyclicBarrier" class="headerlink" title="CyclicBarrier"></a>CyclicBarrier</h2><p>定义：可以理解为一个加法计数器</p><p>用法：CyclicBarrier支持一格可选的<code>Runnable</code>命令，每个屏障点运行一次，在派对在的最后一格线程到达之后，但在任何线程释放之前，在任何一方继续进行之前，此屏障点操作对更新共享状态很有用。</p><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">CyclicBarrierDemo</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line">        CyclicBarrier cyclicBarrier = <span class="keyword">new</span> CyclicBarrier(<span class="number">10</span>,() -&gt; &#123;</span><br><span class="line">            System.out.println(<span class="string">&quot;小明有10元钱，可以打游戏了&quot;</span>);</span><br><span class="line">        &#125;);</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">1</span>; i &lt;= <span class="number">10</span> ; i++) &#123;</span><br><span class="line">            <span class="keyword">final</span> <span class="keyword">int</span> temp = i;</span><br><span class="line">            <span class="keyword">new</span> Thread(() -&gt; &#123;</span><br><span class="line">                System.out.println(<span class="string">&quot;小明现在&quot;</span>+temp+<span class="string">&quot;元,还不能打游戏&quot;</span>);</span><br><span class="line">                <span class="keyword">try</span> &#123;</span><br><span class="line">                    <span class="comment">//cyclicBarrier.await()会一直阻塞直到值为10的时候，才会去执行， System.out.println(&quot;小明有10元钱，可以打游戏了&quot;);这个线程</span></span><br><span class="line">                    <span class="comment">//如果这里循环9次，它会一直阻塞在这里。</span></span><br><span class="line">                    cyclicBarrier.await();</span><br><span class="line">                &#125; <span class="keyword">catch</span> (InterruptedException e) &#123;</span><br><span class="line">                    e.printStackTrace();</span><br><span class="line">                &#125; <span class="keyword">catch</span> (BrokenBarrierException e) &#123;</span><br><span class="line">                    e.printStackTrace();</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;).start();</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">//执行结果</span></span><br><span class="line">小明现在<span class="number">1</span>元,还不能打游戏</span><br><span class="line">小明现在<span class="number">4</span>元,还不能打游戏</span><br><span class="line">小明现在<span class="number">3</span>元,还不能打游戏</span><br><span class="line">小明现在<span class="number">2</span>元,还不能打游戏</span><br><span class="line">小明现在<span class="number">6</span>元,还不能打游戏</span><br><span class="line">小明现在<span class="number">5</span>元,还不能打游戏</span><br><span class="line">小明现在<span class="number">7</span>元,还不能打游戏</span><br><span class="line">小明现在<span class="number">8</span>元,还不能打游戏</span><br><span class="line">小明现在<span class="number">9</span>元,还不能打游戏</span><br><span class="line">小明现在<span class="number">10</span>元,还不能打游戏</span><br><span class="line">小明有<span class="number">10</span>元钱，可以打游戏了</span><br></pre></td></tr></table></figure><h2 id="Semaphore"><a href="#Semaphore" class="headerlink" title="Semaphore"></a>Semaphore</h2><p>定义：相当于信号量</p><p>用法：一个个计数信号量。 在概念上，信号量维持一组许可证。 如果有必要，每个<code>acquire()</code>都会阻塞，直到许可证可用，然后才能使用它。 每个<code>release()</code>添加许可证，潜在地释放阻塞获取方。 但是，没有使用实际的许可证对象; Semaphore只保留可用数量的计数，并相应地执行</p><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">SemaphoreDemo</span> </span>&#123;</span><br><span class="line">    <span class="comment">//例子：打游戏，一共2台电脑,但是有4个人想玩</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line">        <span class="comment">//这个参数表示最大2个线程数</span></span><br><span class="line">        Semaphore semaphore = <span class="keyword">new</span> Semaphore(<span class="number">2</span>);</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">1</span>; i &lt;= <span class="number">4</span>; i++) &#123;</span><br><span class="line">            <span class="keyword">new</span> Thread(() -&gt; &#123;</span><br><span class="line">                <span class="keyword">try</span> &#123;</span><br><span class="line">                    <span class="comment">//获得</span></span><br><span class="line">                    semaphore.acquire();</span><br><span class="line">                    System.out.println(Thread.currentThread().getName()+<span class="string">&quot;号小朋友，抢到了电脑可以完游戏了&quot;</span>);</span><br><span class="line">                    Thread.sleep(<span class="number">5000</span>);</span><br><span class="line">                    System.out.println(Thread.currentThread().getName()+<span class="string">&quot;号小朋友，玩了5秒钟，被他妈妈叫走了&quot;</span>);</span><br><span class="line">                &#125; <span class="keyword">catch</span> (InterruptedException e) &#123;</span><br><span class="line">                    e.printStackTrace();</span><br><span class="line">                &#125;<span class="keyword">finally</span> &#123;</span><br><span class="line">                    <span class="comment">//释放</span></span><br><span class="line">                    semaphore.release();</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;,String.valueOf(i)).start();</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">//执行结果</span></span><br><span class="line"><span class="number">1</span>号小朋友，抢到了电脑可以完游戏了</span><br><span class="line"><span class="number">3</span>号小朋友，抢到了电脑可以完游戏了</span><br><span class="line"><span class="number">3</span>号小朋友，玩了<span class="number">5</span>秒钟，被他妈妈叫走了</span><br><span class="line"><span class="number">1</span>号小朋友，玩了<span class="number">5</span>秒钟，被他妈妈叫走了</span><br><span class="line"><span class="number">2</span>号小朋友，抢到了电脑可以完游戏了</span><br><span class="line"><span class="number">4</span>号小朋友，抢到了电脑可以完游戏了</span><br><span class="line"><span class="number">2</span>号小朋友，玩了<span class="number">5</span>秒钟，被他妈妈叫走了</span><br><span class="line"><span class="number">4</span>号小朋友，玩了<span class="number">5</span>秒钟，被他妈妈叫走了</span><br></pre></td></tr></table></figure><p>理解：</p><pre><code>`semaphore.acquire()`会获取线程，如果线程满了，它会等待线程释放，然后在去获取。（相当于减1）` semaphore.release()`释放线程,然后唤醒等待的线程。（相当于加1）</code></pre><p>作用：</p><pre><code>多个共享资源互斥的时候使用并发限流，保证最大线程数</code></pre><h1 id="读写锁"><a href="#读写锁" class="headerlink" title="读写锁"></a>读写锁</h1><blockquote><p>ReadWriteLock</p></blockquote><p>ReadWriteLock维护一堆关联的locks，一个用于只读操作，一个用于写入操作，read lock可以有多个线程同时进行，write lock只有一个。</p><p>读锁也叫<code>共享锁</code>（一次可以多个线程共享）</p><p>写锁也叫<code>独占锁</code>,<code>排它锁</code>（一次只能一个线程独有）</p><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">ReadWriteLockDemo</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line">        MyCache myCache = <span class="keyword">new</span> MyCache();</span><br><span class="line"></span><br><span class="line">        <span class="comment">//写入</span></span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">1</span>; i &lt;= <span class="number">10</span> ; i++) &#123;</span><br><span class="line">            <span class="keyword">final</span> <span class="keyword">int</span> temp = i;</span><br><span class="line">            <span class="keyword">new</span> Thread(() -&gt; &#123;</span><br><span class="line">                myCache.put(temp+<span class="string">&quot;&quot;</span>,temp+<span class="string">&quot;&quot;</span>);</span><br><span class="line">            &#125;,String.valueOf(i)).start();</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="comment">//读取</span></span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">1</span>; i &lt;= <span class="number">10</span> ; i++) &#123;</span><br><span class="line">            <span class="keyword">final</span> <span class="keyword">int</span> temp = i;</span><br><span class="line">            <span class="keyword">new</span> Thread(() -&gt; &#123;</span><br><span class="line">                myCache.get(temp+<span class="string">&quot;&quot;</span>);</span><br><span class="line">            &#125;,String.valueOf(i)).start();</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">MyCache</span></span>&#123;</span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">volatile</span> Map&lt;String,Object&gt; map = <span class="keyword">new</span> HashMap&lt;&gt;();</span><br><span class="line">    <span class="comment">//获取读写锁</span></span><br><span class="line">    <span class="keyword">private</span> ReadWriteLock readWriteLock = <span class="keyword">new</span> ReentrantReadWriteLock();</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">put</span><span class="params">(String key,Object value)</span></span>&#123;</span><br><span class="line">        <span class="comment">//获取写锁</span></span><br><span class="line">        readWriteLock.writeLock().lock();</span><br><span class="line">        <span class="keyword">try</span> &#123;</span><br><span class="line">            System.out.println(Thread.currentThread().getName()+<span class="string">&quot;线程,写入&quot;</span>+key);</span><br><span class="line">            Object o = map.put(key,value);</span><br><span class="line">            System.out.println(Thread.currentThread().getName()+<span class="string">&quot;线程,写入完毕&quot;</span>);</span><br><span class="line">        &#125;<span class="keyword">catch</span> (Exception e)&#123;</span><br><span class="line">            e.getMessage();</span><br><span class="line">        &#125;<span class="keyword">finally</span> &#123;</span><br><span class="line">            <span class="comment">//关闭写锁</span></span><br><span class="line">            readWriteLock.writeLock().unlock();</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">get</span><span class="params">(String key)</span></span>&#123;</span><br><span class="line">        <span class="comment">//获取读锁</span></span><br><span class="line">        readWriteLock.readLock().lock();</span><br><span class="line">        <span class="keyword">try</span> &#123;</span><br><span class="line">            System.out.println(Thread.currentThread().getName()+<span class="string">&quot;线程,读取&quot;</span>+key);</span><br><span class="line">            Object o = map.get(key);</span><br><span class="line">            System.out.println(Thread.currentThread().getName()+<span class="string">&quot;线程,读取完毕&quot;</span>);</span><br><span class="line">        &#125;<span class="keyword">catch</span> (Exception e)&#123;</span><br><span class="line">            e.getMessage();</span><br><span class="line">        &#125;<span class="keyword">finally</span> &#123;</span><br><span class="line">            <span class="comment">//关闭锁</span></span><br><span class="line">            readWriteLock.readLock().unlock();</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h1 id="阻塞队列"><a href="#阻塞队列" class="headerlink" title="阻塞队列"></a>阻塞队列</h1><p><code>BlockingQueue</code>常用的实现类：<code>ArrayBlockingQueue</code>,<code>LinkedBlockingQueue</code>,<code>SynchronousQueue</code></p><p><img src= "/img/loading.gif" data-lazy-src="https://cdn.jsdelivr.net/gh/my-zhb/CDN/img/20201216175649.png" alt="image-20201216175639630"></p><p><code>什么情况下会使用阻塞队列：多线程并发处理，线程池</code></p><p><code>队列是先去先出</code></p><h2 id="ArrayBlockingQueue"><a href="#ArrayBlockingQueue" class="headerlink" title="ArrayBlockingQueue"></a>ArrayBlockingQueue</h2><blockquote><p>四组API</p></blockquote><table><thead><tr><th align="center">方法</th><th align="center">抛出异常</th><th align="center">有返回值，不抛出异常</th><th align="center">阻塞等待</th><th align="center">超时等待</th></tr></thead><tbody><tr><td align="center">添加</td><td align="center">add()</td><td align="center">offer()[E e]</td><td align="center">put()</td><td align="center">offer()[E e, long timeout, TimeUnit unit]</td></tr><tr><td align="center">移除</td><td align="center">remove()</td><td align="center">poll()</td><td align="center">take()</td><td align="center">poll()[long timeout, TimeUnit unit]</td></tr><tr><td align="center">检查队列首元素</td><td align="center">element()</td><td align="center">peek()</td><td align="center"></td><td align="center"></td></tr></tbody></table><ol><li>抛出异常</li></ol><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">test1</span><span class="params">()</span></span>&#123;</span><br><span class="line">    <span class="comment">//创建array队列，给定大小3</span></span><br><span class="line">    ArrayBlockingQueue&lt;String&gt; queue = <span class="keyword">new</span> ArrayBlockingQueue&lt;String&gt;(<span class="number">3</span>);</span><br><span class="line">    <span class="comment">//添加元素</span></span><br><span class="line">    System.out.println(queue.add(<span class="string">&quot;1&quot;</span>));</span><br><span class="line">    System.out.println(queue.add(<span class="string">&quot;2&quot;</span>));</span><br><span class="line">    System.out.println(queue.add(<span class="string">&quot;3&quot;</span>));</span><br><span class="line">    <span class="comment">//添加第四个抛出异常，java.lang.IllegalStateException: Queue full 队列已满</span></span><br><span class="line">    <span class="comment">//System.out.println(queue.add(&quot;4&quot;));</span></span><br><span class="line">    </span><br><span class="line">    <span class="comment">//检查队首</span></span><br><span class="line">    System.out.println(queue.element());</span><br><span class="line"></span><br><span class="line">    <span class="comment">//移除元素</span></span><br><span class="line">    System.out.println(queue.remove());</span><br><span class="line">    System.out.println(queue.remove());</span><br><span class="line">    System.out.println(queue.remove());</span><br><span class="line">    <span class="comment">//移除第四个抛出异常，java.util.NoSuchElementException 队列已空</span></span><br><span class="line">    <span class="comment">//System.out.println(queue.remove());</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><ol start="2"><li>有返回值，不抛出异常</li></ol><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">test2</span><span class="params">()</span></span>&#123;</span><br><span class="line">    <span class="comment">//创建array队列，给定大小3</span></span><br><span class="line">    ArrayBlockingQueue&lt;String&gt; queue = <span class="keyword">new</span> ArrayBlockingQueue&lt;String&gt;(<span class="number">3</span>);</span><br><span class="line">    <span class="comment">//添加元素</span></span><br><span class="line">    System.out.println(queue.offer(<span class="string">&quot;1&quot;</span>));</span><br><span class="line">    System.out.println(queue.offer(<span class="string">&quot;2&quot;</span>));</span><br><span class="line">    System.out.println(queue.offer(<span class="string">&quot;3&quot;</span>));</span><br><span class="line">    <span class="comment">//返回false，不会抛出异常</span></span><br><span class="line">    System.out.println(queue.offer(<span class="string">&quot;4&quot;</span>));</span><br><span class="line"></span><br><span class="line">    <span class="comment">//检查队首</span></span><br><span class="line">    System.out.println(queue.peek());</span><br><span class="line">    </span><br><span class="line">    <span class="comment">//移除元素</span></span><br><span class="line">    System.out.println(queue.poll());</span><br><span class="line">    System.out.println(queue.poll());</span><br><span class="line">    System.out.println(queue.poll());</span><br><span class="line">    <span class="comment">//返回null，不会抛出异常</span></span><br><span class="line">    System.out.println(queue.poll());</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><ol start="3"><li>阻塞等待</li></ol><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">test3</span><span class="params">()</span> <span class="keyword">throws</span> InterruptedException </span>&#123;</span><br><span class="line">    <span class="comment">//创建array队列，给定大小3</span></span><br><span class="line">    ArrayBlockingQueue&lt;String&gt; queue = <span class="keyword">new</span> ArrayBlockingQueue&lt;String&gt;(<span class="number">3</span>);</span><br><span class="line">    <span class="comment">//添加元素</span></span><br><span class="line">    queue.put(<span class="string">&quot;1&quot;</span>);</span><br><span class="line">    queue.put(<span class="string">&quot;2&quot;</span>);</span><br><span class="line">    queue.put(<span class="string">&quot;3&quot;</span>);</span><br><span class="line">    <span class="comment">//当第四往里存的时候会一直等待(阻塞)</span></span><br><span class="line">    queue.put(<span class="string">&quot;4&quot;</span>);</span><br><span class="line"></span><br><span class="line">    <span class="comment">//移除元素</span></span><br><span class="line">    System.out.println(queue.take());</span><br><span class="line">    System.out.println(queue.take());</span><br><span class="line">    System.out.println(queue.take());</span><br><span class="line">    <span class="comment">//当里面没有元素的时候，在去取，它会一直等待(阻塞)</span></span><br><span class="line">    System.out.println(queue.take());</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><ol start="4"><li>超时等待</li></ol><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">test4</span><span class="params">()</span> <span class="keyword">throws</span> InterruptedException </span>&#123;</span><br><span class="line">    <span class="comment">//创建array队列，给定大小3</span></span><br><span class="line">    ArrayBlockingQueue&lt;String&gt; queue = <span class="keyword">new</span> ArrayBlockingQueue&lt;String&gt;(<span class="number">3</span>);</span><br><span class="line">    <span class="comment">//添加元素</span></span><br><span class="line">    System.out.println(queue.offer(<span class="string">&quot;1&quot;</span>));</span><br><span class="line">    System.out.println(queue.offer(<span class="string">&quot;2&quot;</span>));</span><br><span class="line">    System.out.println(queue.offer(<span class="string">&quot;3&quot;</span>));</span><br><span class="line">    <span class="comment">//添加第四个元素等待3秒，如果3秒过后还没位子，就自动退出</span></span><br><span class="line">    System.out.println(queue.offer(<span class="string">&quot;4&quot;</span>,<span class="number">3</span>, TimeUnit.SECONDS));</span><br><span class="line"></span><br><span class="line">    System.out.println(queue.peek());</span><br><span class="line"></span><br><span class="line">    <span class="comment">//移除元素</span></span><br><span class="line">    System.out.println(queue.poll());</span><br><span class="line">    System.out.println(queue.poll());</span><br><span class="line">    System.out.println(queue.poll());</span><br><span class="line">    <span class="comment">//移除，也是同理 先等待3秒，有就移除，3秒过后自动退出</span></span><br><span class="line">    System.out.println(queue.poll(<span class="number">3</span>,TimeUnit.SECONDS));</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="SynchronousQueue同步队列"><a href="#SynchronousQueue同步队列" class="headerlink" title="SynchronousQueue同步队列"></a>SynchronousQueue同步队列</h2><p><code>这个队列容量为1，进入一个元素之后，必选把这个元素取出来才能继续存</code>,对应的存是<code>put()</code>,取是<code>take()</code></p><figure class="highlight java"><table><tr><td class="code"><pre><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">test5</span><span class="params">()</span> <span class="keyword">throws</span> InterruptedException </span>&#123;</span><br><span class="line">        SynchronousQueue&lt;String&gt; synchronousQueue = <span class="keyword">new</span> SynchronousQueue&lt;String&gt;();</span><br><span class="line">        <span class="keyword">new</span> Thread(() -&gt; &#123;</span><br><span class="line">            <span class="keyword">try</span> &#123;</span><br><span class="line">                System.out.println(Thread.currentThread().getName()+<span class="string">&quot;线程写入==&gt;&gt;&quot;</span>+<span class="number">1</span>);</span><br><span class="line">                synchronousQueue.put(<span class="number">1</span>+<span class="string">&quot;&quot;</span>);</span><br><span class="line">                System.out.println(Thread.currentThread().getName()+<span class="string">&quot;线程写入==&gt;&gt;&quot;</span>+<span class="number">2</span>);</span><br><span class="line">                synchronousQueue.put(<span class="number">2</span>+<span class="string">&quot;&quot;</span>);</span><br><span class="line">                System.out.println(Thread.currentThread().getName()+<span class="string">&quot;线程写入==&gt;&gt;&quot;</span>+<span class="number">3</span>);</span><br><span class="line">                synchronousQueue.put(<span class="number">3</span>+<span class="string">&quot;&quot;</span>);</span><br><span class="line">            &#125; <span class="keyword">catch</span> (InterruptedException e) &#123;</span><br><span class="line">                e.printStackTrace();</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;,<span class="string">&quot;A&quot;</span>).start();</span><br><span class="line">        <span class="keyword">new</span> Thread(() -&gt; &#123;</span><br><span class="line">            <span class="keyword">try</span> &#123;</span><br><span class="line">                TimeUnit.SECONDS.sleep(<span class="number">2</span>);</span><br><span class="line">                System.out.println(Thread.currentThread().getName()+<span class="string">&quot;线程取出==&gt;&gt;&quot;</span>+synchronousQueue.take());</span><br><span class="line">                TimeUnit.SECONDS.sleep(<span class="number">2</span>);</span><br><span class="line">                System.out.println(Thread.currentThread().getName()+<span class="string">&quot;线程取出==&gt;&gt;&quot;</span>+synchronousQueue.take());</span><br><span class="line">                TimeUnit.SECONDS.sleep(<span class="number">2</span>);</span><br><span class="line">                System.out.println(Thread.currentThread().getName()+<span class="string">&quot;线程取出==&gt;&gt;&quot;</span>+synchronousQueue.take());</span><br><span class="line">            &#125; <span class="keyword">catch</span> (InterruptedException e) &#123;</span><br><span class="line">                e.printStackTrace();</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;,<span class="string">&quot;B&quot;</span>).start();</span><br><span class="line">    &#125;</span><br><span class="line"><span class="comment">//结果</span></span><br><span class="line">A线程写入==&gt;&gt;<span class="number">1</span></span><br><span class="line">B线程取出==&gt;&gt;<span class="number">1</span></span><br><span class="line">A线程写入==&gt;&gt;<span class="number">2</span></span><br><span class="line">B线程取出==&gt;&gt;<span class="number">2</span></span><br><span class="line">A线程写入==&gt;&gt;<span class="number">3</span></span><br><span class="line">B线程取出==&gt;&gt;<span class="number">3</span></span><br></pre></td></tr></table></figure><h1 id="线程池-重要"><a href="#线程池-重要" class="headerlink" title="线程池(重要)"></a>线程池(重要)</h1><blockquote><p>池化技术</p></blockquote><p>程序的运行会占用系统的资源,优化资源的使用称之为<code>池化技术</code>，如：线程池、内存池、对象池等等</p><p>如果平凡的创建、销毁非常浪费资源。</p><p><code>池化技术：就是事先准备好一些资源，有人要用，就直接在这里拿，用完之后在换回来</code></p><blockquote><p>线程池的好处</p></blockquote><ol><li>降低资源的消耗</li><li>提高响应的速度</li><li>方便管理</li></ol><p><code>总结：线程可复用，可以控制最大并发数，可以管理线程</code></p><blockquote><p>线程池——三大方法</p></blockquote><ol><li><code>Executors.newSingleThreadExecutor()</code>单个线程</li><li><code>Executors.newFixedThreadPool(3)</code>自定义最大线程数</li><li><code>Executors.newCachedThreadPool()</code>可伸缩的</li></ol><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line">    ExecutorService service1 = Executors.newSingleThreadExecutor();</span><br><span class="line">    ExecutorService service2 = Executors.newFixedThreadPool(<span class="number">3</span>);</span><br><span class="line">    ExecutorService service3 = Executors.newCachedThreadPool();</span><br><span class="line">    <span class="keyword">try</span> &#123;</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt;<span class="number">100</span> ; i++) &#123;</span><br><span class="line">            service1.execute(() -&gt; &#123;</span><br><span class="line">                System.out.println(Thread.currentThread().getName());</span><br><span class="line">            &#125;);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;<span class="keyword">catch</span> (Exception e)&#123;</span><br><span class="line">        e.printStackTrace();</span><br><span class="line">    &#125;<span class="keyword">finally</span> &#123;</span><br><span class="line">        <span class="comment">//关闭线程池</span></span><br><span class="line">        service1.shutdown();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><blockquote><p>线程池——七大参数</p></blockquote><p>三大方法的底层都调用的是：<code>ThreadPoolExecutor</code></p><ol><li><code>int corePoolSize</code> ——&gt; 核心线程池大小</li><li><code>int maximumPoolSize</code> ——&gt; 最大核心线程池大小</li><li><code>long keepAliveTime</code> ——&gt; 超时时间，如果超时了，自动释放</li><li><code>TimeUnit unit</code> ——&gt; 超时单位</li><li><code>BlockingQueue&lt;Runnable&gt; workQueue</code> ——&gt; 阻塞队列</li><li><code>ThreadFactory threadFactory</code> ——&gt; 线程工厂，创建线程使用，一般不用动</li><li><code>RejectedExecutionHandler handler</code> ——&gt; 拒绝策略</li></ol><figure class="highlight java"><table><tr><td class="code"><pre><span class="line">   <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> ExecutorService <span class="title">newSingleThreadExecutor</span><span class="params">()</span> </span>&#123;</span><br><span class="line">       <span class="keyword">return</span> <span class="keyword">new</span> FinalizableDelegatedExecutorService</span><br><span class="line">           (<span class="keyword">new</span> ThreadPoolExecutor(<span class="number">1</span>, <span class="number">1</span>,</span><br><span class="line">                                   <span class="number">0L</span>, TimeUnit.MILLISECONDS,</span><br><span class="line">                                   <span class="keyword">new</span> LinkedBlockingQueue&lt;Runnable&gt;()));</span><br><span class="line">   &#125;</span><br><span class="line">   <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> ExecutorService <span class="title">newFixedThreadPool</span><span class="params">(<span class="keyword">int</span> nThreads)</span> </span>&#123;</span><br><span class="line">       <span class="keyword">return</span> <span class="keyword">new</span> ThreadPoolExecutor(nThreads, nThreads,</span><br><span class="line">                                     <span class="number">0L</span>, TimeUnit.MILLISECONDS,</span><br><span class="line">                                     <span class="keyword">new</span> LinkedBlockingQueue&lt;Runnable&gt;());</span><br><span class="line">   &#125;</span><br><span class="line">   <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> ExecutorService <span class="title">newCachedThreadPool</span><span class="params">()</span> </span>&#123;</span><br><span class="line">       <span class="keyword">return</span> <span class="keyword">new</span> ThreadPoolExecutor(<span class="number">0</span>, Integer.MAX_VALUE,</span><br><span class="line">                                     <span class="number">60L</span>, TimeUnit.SECONDS,</span><br><span class="line">                                     <span class="keyword">new</span> SynchronousQueue&lt;Runnable&gt;());</span><br><span class="line">   &#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="title">ThreadPoolExecutor</span><span class="params">(<span class="keyword">int</span> corePoolSize, //核心线程池大小</span></span></span><br><span class="line"><span class="function"><span class="params">                             <span class="keyword">int</span> maximumPoolSize,//最大核心线程池大小</span></span></span><br><span class="line"><span class="function"><span class="params">                             <span class="keyword">long</span> keepAliveTime,//超时时间，如果超时了，自动释放</span></span></span><br><span class="line"><span class="function"><span class="params">                             TimeUnit unit,//超时单位</span></span></span><br><span class="line"><span class="function"><span class="params">                             BlockingQueue&lt;Runnable&gt; workQueue,//阻塞队列</span></span></span><br><span class="line"><span class="function"><span class="params">                             ThreadFactory threadFactory,//线程工厂，创建线程使用，一般不用动</span></span></span><br><span class="line"><span class="function"><span class="params">                             RejectedExecutionHandler handler)</span> <span class="comment">//拒绝策略</span></span></span><br><span class="line"><span class="function">   </span>&#123;</span><br><span class="line">       <span class="keyword">if</span> (corePoolSize &lt; <span class="number">0</span> ||</span><br><span class="line">           maximumPoolSize &lt;= <span class="number">0</span> ||</span><br><span class="line">           maximumPoolSize &lt; corePoolSize ||</span><br><span class="line">           keepAliveTime &lt; <span class="number">0</span>)</span><br><span class="line">           <span class="keyword">throw</span> <span class="keyword">new</span> IllegalArgumentException();</span><br><span class="line">       <span class="keyword">if</span> (workQueue == <span class="keyword">null</span> || threadFactory == <span class="keyword">null</span> || handler == <span class="keyword">null</span>)</span><br><span class="line">           <span class="keyword">throw</span> <span class="keyword">new</span> NullPointerException();</span><br><span class="line">       <span class="keyword">this</span>.corePoolSize = corePoolSize;</span><br><span class="line">       <span class="keyword">this</span>.maximumPoolSize = maximumPoolSize;</span><br><span class="line">       <span class="keyword">this</span>.workQueue = workQueue;</span><br><span class="line">       <span class="keyword">this</span>.keepAliveTime = unit.toNanos(keepAliveTime);</span><br><span class="line">       <span class="keyword">this</span>.threadFactory = threadFactory;</span><br><span class="line">       <span class="keyword">this</span>.handler = handler;</span><br><span class="line">   &#125;</span><br></pre></td></tr></table></figure><blockquote><p>自定义线程池</p></blockquote><p>i&lt;=4,有2个线程在执行，因为队列未满</p><p>i&lt;=5,有2个线程在执行，因为队列未满</p><p>i&lt;=6,有3个线程在执行，因为队列已满</p><p>i&lt;=7,有4个线程在执行，因为队列已满</p><p>i&lt;=8,有5个线程在执行，因为队列已满</p><p>i&lt;=9,报错 因为已经超出最大承载了，最大承载为5+3（最大核心线程数+队列容量）</p><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line">    ExecutorService service1 = <span class="keyword">new</span> ThreadPoolExecutor(</span><br><span class="line">            <span class="number">2</span>,<span class="comment">//核心线程2</span></span><br><span class="line">            <span class="number">5</span>,<span class="comment">//最大核心线程5</span></span><br><span class="line">            <span class="number">3</span>,<span class="comment">//等待时长3秒</span></span><br><span class="line">            TimeUnit.SECONDS,</span><br><span class="line">            <span class="keyword">new</span> LinkedBlockingDeque&lt;&gt;(<span class="number">3</span>),<span class="comment">//队列容量3</span></span><br><span class="line">            Executors.defaultThreadFactory(),</span><br><span class="line">            <span class="keyword">new</span> ThreadPoolExecutor.AbortPolicy()<span class="comment">//表示如果队列满了，还有人进来，就不处理，抛出异常</span></span><br><span class="line">            );</span><br><span class="line">    <span class="keyword">try</span> &#123;</span><br><span class="line">        <span class="comment">//最大承载Deque+maximumPoolSize(最大核心线程)</span></span><br><span class="line">        <span class="comment">//如果超出就会报错java.util.concurrent.RejectedExecutionException</span></span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">1</span>; i &lt;=<span class="number">9</span> ; i++) &#123;</span><br><span class="line">            service1.execute(() -&gt; &#123;</span><br><span class="line">                System.out.println(Thread.currentThread().getName());</span><br><span class="line">            &#125;);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;<span class="keyword">catch</span> (Exception e)&#123;</span><br><span class="line">        e.printStackTrace();</span><br><span class="line">    &#125;<span class="keyword">finally</span> &#123;</span><br><span class="line">        <span class="comment">//关闭线程池</span></span><br><span class="line">        service1.shutdown();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><blockquote><p>四种拒绝策略</p></blockquote><ol><li><code>new ThreadPoolExecutor.AbortPolicy()</code>——&gt; 表示如果队列满了，还有人进来，就不处理，抛出异常</li><li><code>new ThreadPoolExecutor.CallerRunsPolicy()</code>——&gt; 哪里来的就回哪里去，如果是main线程来的就回main线程</li><li><code>new ThreadPoolExecutor.DiscardOldestPolicy()</code>——&gt; 如果队列满了，它会尝试和最早的竞争，如果成功，就会执行，如果失败，就会被抛弃，也不会抛出异常</li><li><code>new ThreadPoolExecutor.DiscardPolicy() </code>——&gt; 如果队列满了就会丢掉任务，不会抛出异常</li></ol><blockquote><p>如何去设置线程池最大的大小</p></blockquote><ol><li><code>CPU密集型</code>，电脑几核，就是几核，可以保证CPU的效率最高！</li><li><code>IO密集型</code>，判断你程序中十分消耗IO的线程，只要大于就可以</li></ol><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="comment">//获取CPU的核数 </span></span><br><span class="line">System.out.println(Runtime.getRuntime().availableProcessors());</span><br></pre></td></tr></table></figure><h1 id="四大函数式接口-重要"><a href="#四大函数式接口-重要" class="headerlink" title="四大函数式接口(重要)"></a>四大函数式接口(重要)</h1><blockquote><p>函数式接口–&gt;只有一个方法的接口</p></blockquote><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="meta">@FunctionalInterface</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">interface</span> <span class="title">Runnable</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">abstract</span> <span class="keyword">void</span> <span class="title">run</span><span class="params">()</span></span>;</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">//简化编程模型，在新版本的框架底层大量使用</span></span><br></pre></td></tr></table></figure><p>四大函数式接口：<code>Consumer</code>、<code>Function</code>、<code>Predicate</code>、<code>Supplier</code></p><ol><li>Function</li></ol><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="comment">//Function函数接口，有一个输入参数，有一个输出</span></span><br><span class="line"><span class="comment">//只要是函数型接口都可以通过lambda表达是简化</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">FunctionDemo</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line">        Function&lt;String,String&gt; function = str -&gt; &#123;</span><br><span class="line">            <span class="keyword">return</span> str;</span><br><span class="line">        &#125;;</span><br><span class="line">        System.out.println(function.apply(<span class="string">&quot;231&quot;</span>));</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line">输出结果：</span><br><span class="line"><span class="number">231</span></span><br></pre></td></tr></table></figure><ol start="2"><li>Predicate（断定型接口）</li></ol><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="comment">//Predicate函数接口，有一个输入参数，会固定返回一个boolean值</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">PredicateDemo</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line">        Predicate&lt;String&gt; predicate = (str)-&gt;&#123;</span><br><span class="line">            <span class="keyword">return</span> str.equals(<span class="string">&quot;123&quot;</span>);</span><br><span class="line">        &#125;;</span><br><span class="line">        System.out.println(predicate.test(<span class="string">&quot;123&quot;</span>));</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line">输出结果：</span><br><span class="line"><span class="keyword">true</span></span><br></pre></td></tr></table></figure><ol start="3"><li>Consumer(消费型接口)</li></ol><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="comment">//Consumer 消费型接口，只有输入，没有返回</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">ConsumerDemo</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line">        Consumer&lt;String&gt; consumer = str -&gt; &#123;</span><br><span class="line">            System.out.println(str);</span><br><span class="line">        &#125;;</span><br><span class="line">        consumer.accept(<span class="string">&quot;123&quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><ol start="4"><li>Supplier(生产型接口)</li></ol><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="comment">//Supplier 生产型接口，没有输入，只有返回</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">SupplierDemo</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line">        Supplier&lt;String&gt; supplier = () -&gt;&#123;</span><br><span class="line">          <span class="keyword">return</span> String.valueOf(<span class="number">1024</span>);</span><br><span class="line">        &#125;;</span><br><span class="line">        System.out.println(supplier.get());</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line">输出结果：</span><br><span class="line"><span class="number">1024</span></span><br></pre></td></tr></table></figure><h1 id="Stream流式计算"><a href="#Stream流式计算" class="headerlink" title="Stream流式计算"></a>Stream流式计算</h1><blockquote><p>什么是Stream流式计算</p></blockquote><p>存储+计算，集合、Mysql本质就是存储东西的，计算机应该交给流来操作！</p><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Demo</span> </span>&#123;</span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * 一分钟内完成此题，只能用一行代码实现</span></span><br><span class="line"><span class="comment">     * 现在有5个用户，筛选：</span></span><br><span class="line"><span class="comment">     * 1. ID 必须是偶数</span></span><br><span class="line"><span class="comment">     * 2. 年龄必须大于23岁</span></span><br><span class="line"><span class="comment">     * 3. 用户名转大写字母</span></span><br><span class="line"><span class="comment">     * 4. 用户名字母倒序</span></span><br><span class="line"><span class="comment">     * 5. 只输出一个用户！</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line">        User u1 = <span class="keyword">new</span> User(<span class="number">1</span>,<span class="string">&quot;a&quot;</span>,<span class="number">21</span>);</span><br><span class="line">        User u2 = <span class="keyword">new</span> User(<span class="number">2</span>,<span class="string">&quot;b&quot;</span>,<span class="number">22</span>);</span><br><span class="line">        User u3 = <span class="keyword">new</span> User(<span class="number">3</span>,<span class="string">&quot;c&quot;</span>,<span class="number">23</span>);</span><br><span class="line">        User u4 = <span class="keyword">new</span> User(<span class="number">4</span>,<span class="string">&quot;d&quot;</span>,<span class="number">24</span>);</span><br><span class="line">        User u5 = <span class="keyword">new</span> User(<span class="number">6</span>,<span class="string">&quot;e&quot;</span>,<span class="number">25</span>);</span><br><span class="line">        List&lt;User&gt; list = Arrays.asList(u1, u2, u3, u4, u5);</span><br><span class="line">        <span class="comment">//链式计算</span></span><br><span class="line">        list.stream()</span><br><span class="line">                .filter(u-&gt;&#123;<span class="keyword">return</span> u.getId()%<span class="number">2</span>==<span class="number">0</span>;&#125;)</span><br><span class="line">                .filter(u-&gt;&#123;<span class="keyword">return</span> u.getAge()&gt;<span class="number">23</span>;&#125;)</span><br><span class="line">                .map(u-&gt;&#123;<span class="keyword">return</span> u.getName().toUpperCase();&#125;)</span><br><span class="line">                .sorted((uu1,uu2)-&gt;&#123;<span class="keyword">return</span> uu2.compareTo(uu1);&#125;)</span><br><span class="line">                .limit(<span class="number">1</span>)</span><br><span class="line">                .forEach(System.out::println);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h1 id="ForkJoin"><a href="#ForkJoin" class="headerlink" title="ForkJoin"></a>ForkJoin</h1><blockquote><p>什么是ForkJoin</p></blockquote><p>ForkJoin在JDK1.7，并行执行任务！提高效率，在数据量很大的情况下。</p><p>ForkJoin会把一个大数据量的东西，拆分成小的，如果还是很大，它会继续拆分，每一个小模块都会有一个结果，最后把这些结果汇总。</p><blockquote><p>ForkJoin特点：工作窃取</p></blockquote><p>多线程下如果一个线程做完了该做的，它会把其他线程没做的窃取过来自己做，不然线程等待。这里面维护的都是<code>双端队列</code></p><p><img src= "/img/loading.gif" data-lazy-src="https://cdn.jsdelivr.net/gh/my-zhb/CDN/img/20201221165358.png"></p><blockquote><p>ForkJoin的使用</p></blockquote><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">ForkJoinDemo</span> <span class="keyword">extends</span> <span class="title">RecursiveTask</span>&lt;<span class="title">Long</span>&gt; </span>&#123;</span><br><span class="line">    <span class="keyword">private</span> Long start;</span><br><span class="line">    <span class="keyword">private</span> Long end;</span><br><span class="line">    <span class="comment">//临界值</span></span><br><span class="line">    <span class="keyword">private</span> Long temp=<span class="number">20_0000_0000L</span>;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="title">ForkJoinDemo</span><span class="params">(Long start, Long end)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">this</span>.start = start;</span><br><span class="line">        <span class="keyword">this</span>.end = end;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">protected</span> Long <span class="title">compute</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="keyword">if</span>((end-start)&lt;temp)&#123;</span><br><span class="line">            Long sum = <span class="number">0L</span>;</span><br><span class="line">            <span class="keyword">for</span> (Long i = start; i &lt;= end; i++) &#123;</span><br><span class="line">                sum+=i;</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">return</span> sum;</span><br><span class="line">        &#125;<span class="keyword">else</span>&#123;</span><br><span class="line">            <span class="comment">//中间值</span></span><br><span class="line">            <span class="keyword">long</span> middle = (start+end)&gt;&gt;<span class="number">1</span>;</span><br><span class="line">            ForkJoinDemo task1 = <span class="keyword">new</span> ForkJoinDemo(start,middle);</span><br><span class="line">            task1.fork();<span class="comment">//拆分任务，把任务压入线程队列</span></span><br><span class="line">            ForkJoinDemo task2 = <span class="keyword">new</span> ForkJoinDemo(middle+<span class="number">1</span>,end);</span><br><span class="line">            task2.fork();</span><br><span class="line">            <span class="keyword">return</span> task1.join()+task2.join();</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>测试</p><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Test</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> <span class="keyword">throws</span> ExecutionException, InterruptedException </span>&#123;</span><br><span class="line">        test1();</span><br><span class="line">        test2();</span><br><span class="line">        test3();</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">test1</span><span class="params">()</span></span>&#123;</span><br><span class="line">        Long sum = <span class="number">0L</span>;</span><br><span class="line">        <span class="keyword">long</span> start = System.currentTimeMillis();</span><br><span class="line">        <span class="keyword">for</span> (Long i = <span class="number">1L</span>; i &lt;= <span class="number">10_0000_0000</span> ; i++) &#123;</span><br><span class="line">            sum+=i;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">long</span> end = System.currentTimeMillis();</span><br><span class="line">        System.out.println(<span class="string">&quot;sum=&quot;</span>+sum+<span class="string">&quot;---&gt;&gt;&gt;耗时&quot;</span> +(end-start));</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">//使用forkjoin</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">test2</span><span class="params">()</span> <span class="keyword">throws</span> ExecutionException, InterruptedException </span>&#123;</span><br><span class="line">        <span class="keyword">long</span> start = System.currentTimeMillis();</span><br><span class="line">        ForkJoinPool forkJoinPool = <span class="keyword">new</span> ForkJoinPool();</span><br><span class="line">        ForkJoinTask&lt;Long&gt; task = <span class="keyword">new</span> ForkJoinDemo(<span class="number">0L</span>,<span class="number">10_0000_0000L</span>);</span><br><span class="line">        ForkJoinTask&lt;Long&gt; submit = forkJoinPool.submit(task);</span><br><span class="line">        Long sum = submit.get();</span><br><span class="line">        <span class="keyword">long</span> end = System.currentTimeMillis();</span><br><span class="line">        System.out.println(<span class="string">&quot;sum=&quot;</span>+sum+<span class="string">&quot;---&gt;&gt;&gt;耗时&quot;</span> +(end-start));</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">//Stream 并行流</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">test3</span><span class="params">()</span></span>&#123;</span><br><span class="line">        <span class="keyword">long</span> start = System.currentTimeMillis();</span><br><span class="line">        <span class="keyword">long</span> sum = LongStream.rangeClosed(<span class="number">0L</span>, <span class="number">10_0000_0000L</span>).parallel().reduce(<span class="number">0</span>, Long::sum);</span><br><span class="line">        <span class="keyword">long</span> end = System.currentTimeMillis();</span><br><span class="line">        System.out.println(<span class="string">&quot;sum=&quot;</span>+sum+<span class="string">&quot;---&gt;&gt;&gt;耗时&quot;</span> +(end-start));</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line">测试结果：</span><br><span class="line">sum=<span class="number">500000000500000000</span>---&gt;&gt;&gt;耗时<span class="number">7018</span></span><br><span class="line">sum=<span class="number">500000000500000000</span>---&gt;&gt;&gt;耗时<span class="number">6157</span></span><br><span class="line">sum=<span class="number">500000000500000000</span>---&gt;&gt;&gt;耗时<span class="number">203</span></span><br></pre></td></tr></table></figure><h1 id="异步回调"><a href="#异步回调" class="headerlink" title="异步回调"></a>异步回调</h1><blockquote><p>Future设计初衷：对将来的某个事件的结果进行建模</p></blockquote><ol><li>没有返回的异步</li></ol><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Demo</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> <span class="keyword">throws</span> ExecutionException, InterruptedException </span>&#123;</span><br><span class="line">        CompletableFuture&lt;Void&gt; completableFuture = CompletableFuture.runAsync(() -&gt; &#123;</span><br><span class="line">            <span class="keyword">try</span> &#123;</span><br><span class="line">                TimeUnit.SECONDS.sleep(<span class="number">2</span>);</span><br><span class="line">            &#125; <span class="keyword">catch</span> (InterruptedException e) &#123;</span><br><span class="line">                e.printStackTrace();</span><br><span class="line">            &#125;</span><br><span class="line">            System.out.println(<span class="string">&quot;异步回调&quot;</span>);</span><br><span class="line">        &#125;);</span><br><span class="line">        System.out.println(<span class="string">&quot;我先输出....&quot;</span>);</span><br><span class="line">        <span class="comment">//这里会阻塞等待结果返回</span></span><br><span class="line">        completableFuture.get();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line">执行结果：</span><br><span class="line">我先输出....</span><br><span class="line">异步回调   </span><br></pre></td></tr></table></figure><ol start="2"><li>有返回的异步</li></ol><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Demo</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> <span class="keyword">throws</span> ExecutionException, InterruptedException </span>&#123;</span><br><span class="line">        CompletableFuture&lt;Integer&gt; future = CompletableFuture.supplyAsync(() -&gt; &#123;</span><br><span class="line">            <span class="keyword">return</span> <span class="number">400</span>;</span><br><span class="line">        &#125;);</span><br><span class="line">        System.out.println(</span><br><span class="line">                future.whenComplete((aVoid, throwable) -&gt; &#123;</span><br><span class="line">                    System.out.println(<span class="string">&quot;aVoid=&gt;&quot;</span>+aVoid);<span class="comment">//这里如果是正确就会是正确的返回值，如果错误就为null</span></span><br><span class="line">                    System.out.println(<span class="string">&quot;throwable=&gt;&quot;</span>+throwable);<span class="comment">//如果有错误 这里输出错误</span></span><br><span class="line">                &#125;).exceptionally(e -&gt; &#123;</span><br><span class="line">                    e.getMessage(); <span class="comment">//可以捕获错误</span></span><br><span class="line">                    <span class="keyword">return</span> <span class="number">500</span>;</span><br><span class="line">                &#125;).get()</span><br><span class="line">        );</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line">正确执行结果：</span><br><span class="line">aVoid=&gt;<span class="number">400</span></span><br><span class="line">throwable=&gt;<span class="keyword">null</span></span><br><span class="line"><span class="number">400</span></span><br><span class="line">    </span><br><span class="line">错误执行结果：</span><br><span class="line">aVoid=&gt;<span class="keyword">null</span></span><br><span class="line">throwable=&gt;java.util.concurrent.CompletionException: java.lang.ArithmeticException: / by zero</span><br><span class="line"><span class="number">500</span>    </span><br></pre></td></tr></table></figure><h1 id="JMM"><a href="#JMM" class="headerlink" title="JMM"></a>JMM</h1><blockquote><p>什么是JMM（JMM就是为了保证线程安全）</p></blockquote><p>JMM是Java内存模型，不存在的东西，相当于概念，约定！</p><p><strong>关于JMM的一些同步约定</strong></p><p>1、线程解锁前，<code>必须把共享变量立刻刷回主内存</code>。</p><p>2、线程加锁前，必须读取主内存当中的最新值到工作内存中！</p><p>3、加锁和解锁必须是同一把锁。</p><p><strong>线程：工作内存、主内存</strong></p><p><img src= "/img/loading.gif" data-lazy-src="https://cdn.jsdelivr.net/gh/my-zhb/CDN/img/20201222104707.png"></p><blockquote><p>在JMM中有8种操作</p></blockquote><ul><li>lock(锁定)：作用于主内存的变量，把一个变量标识为线程独占状态。</li><li>unlock(解锁)：作用于主内存的变量，它把一个处于锁定状态的变量释放出来，释放后的变量才能被其他线程锁定。</li><li>read(读取)：作用于主内存变量，它把一个变量从主内存传输到线程的工作内存中，以便随后的load动作使用。</li><li>load(载入)：作用于工作内存中的变量，它把read操作从主内存中变量放入工作内存中。</li><li>use(使用)：作用于工作内存中的变量，它把工作内存中的变量传输给执行引擎，每个虚拟机遇到一个需要使用的变量的值，就会执行这个指令。</li><li>assign(赋值/返还)：作用于工作内存中的变量，它把一个从执行引擎接收到的值放入工作内存的变量副本中。</li><li>store(存储)：作用于主内存中的变量，它把一个从工作内存中的变量的值传送到主内存中，以便后续write使用。</li><li>write(写入)：作用于主内存中的变量，它把store操作从工作内存中获取的变量的值，放入主内存的变量中</li></ul><blockquote><p>JMM对这八种指令的使用，指定了对应的规则</p></blockquote><ul><li>不允许read和load、store和write操作之一单独出现，即使用read就必须load，使用了store就必须write。</li><li>不允许线程丢弃它最近的assign操作，即工作变量的数据改变之后，必须告知主内存。</li><li>不允许一个线程将没用assign的数据从工作内存同步会主内存。</li><li>一个新的变量必须在主内存中诞生，不允许工作内存直接使用一个未被初始化的变量，就是对变量实施use、store操作之前，必须经过assign和load操作。</li><li>一个变量同一时间只有一个线程能对其进行lock，多次lock后，必须执行相同次数的unlock才能解锁。</li><li>如果对一个变量进行lock操作，会清空所有工作内存中此变量的值，在执行引擎使用这个变量前，必须重新load或assign操作初始化变量的值。</li><li>如果对一个变量没有被lock，就不能对其进行unlock操作，也不能unlock一个被其他线程锁住的变量。</li><li>对一个变量进行unlock操作之前，必须把此变量同步回主内存中。</li></ul><blockquote><p> 问题: 假设B线程已经把值写入主内存，怎么才能告诉A线程，主内存中的值已经发生变化？</p></blockquote><p><img src= "/img/loading.gif" data-lazy-src="https://cdn.jsdelivr.net/gh/my-zhb/CDN/img/20201222112724.png"></p><h1 id="Volatile"><a href="#Volatile" class="headerlink" title="Volatile"></a>Volatile</h1><blockquote><p>请你谈谈你对Volatile的理解</p></blockquote><p><strong>Volatile是Java虚拟机提供的轻量级的同步机制</strong></p><p>1、保证可见性</p><p>2、<code>不保证原子性</code></p><p>3、禁止指令重排</p><blockquote><p>保证可见性</p></blockquote><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Demo1</span> </span>&#123;</span><br><span class="line">    <span class="comment">//不加volatile 程序就会死循环</span></span><br><span class="line">    <span class="comment">//加上volatile 可以保证可见性</span></span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">volatile</span> <span class="keyword">static</span> <span class="keyword">int</span> num =<span class="number">0</span> ;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">new</span> Thread(() -&gt; &#123;<span class="comment">//对主内存的变化不知道</span></span><br><span class="line">            <span class="keyword">while</span> (num == <span class="number">0</span>)&#123;&#125;</span><br><span class="line">        &#125;).start();</span><br><span class="line">        <span class="keyword">try</span> &#123;</span><br><span class="line">            TimeUnit.SECONDS.sleep(<span class="number">2</span>);</span><br><span class="line">        &#125; <span class="keyword">catch</span> (InterruptedException e) &#123;</span><br><span class="line">            e.printStackTrace();</span><br><span class="line">        &#125;</span><br><span class="line">        num = <span class="number">1</span>;</span><br><span class="line">        System.out.println(num);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line">运行结果</span><br><span class="line"><span class="number">1</span></span><br></pre></td></tr></table></figure><blockquote><p>不保证原子性</p></blockquote><p>原子性：要么同时成功，要么同时失败</p><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Demo2</span> </span>&#123;</span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">volatile</span> <span class="keyword">static</span> <span class="keyword">int</span> num = <span class="number">0</span>;</span><br><span class="line">    <span class="function"><span class="keyword">private</span>  <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">add</span><span class="params">()</span></span>&#123;</span><br><span class="line">        num++;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">1</span>; i &lt;= <span class="number">10</span> ; i++) &#123;</span><br><span class="line">            <span class="keyword">new</span> Thread(() -&gt; &#123;</span><br><span class="line">                <span class="keyword">for</span> (<span class="keyword">int</span> j = <span class="number">0</span>; j &lt; <span class="number">1000</span> ; j++) &#123;</span><br><span class="line">                    add();</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;).start();</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="comment">//线程数大于2说明没有执行完,多线程下一定不要用if。</span></span><br><span class="line">        <span class="keyword">while</span> (Thread.activeCount()&gt;<span class="number">2</span>)&#123;</span><br><span class="line">            Thread.yield();</span><br><span class="line">        &#125;</span><br><span class="line">        System.out.println(num);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line">运行结果 不是<span class="number">10000</span>  所以不能保证原子性</span><br></pre></td></tr></table></figure><p><strong>如何在不适用synchronized和lock的情况下保证原子性呢！</strong></p><p><code>使用java.util.concurrent.atomic下面的原子类</code>，这样就保证了</p><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Demo2</span> </span>&#123;</span><br><span class="line">    <span class="keyword">private</span>  <span class="keyword">static</span> AtomicInteger num = <span class="keyword">new</span> AtomicInteger();</span><br><span class="line">    <span class="function"><span class="keyword">private</span>  <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">add</span><span class="params">()</span></span>&#123;</span><br><span class="line">        num.getAndIncrement();</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">1</span>; i &lt;= <span class="number">10</span> ; i++) &#123;</span><br><span class="line">            <span class="keyword">new</span> Thread(() -&gt; &#123;</span><br><span class="line">                <span class="keyword">for</span> (<span class="keyword">int</span> j = <span class="number">0</span>; j &lt; <span class="number">1000</span> ; j++) &#123;</span><br><span class="line">                    add();</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;).start();</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="comment">//线程数大于2说明没有执行完,多线程下一定不要用if。</span></span><br><span class="line">        <span class="keyword">while</span> (Thread.activeCount()&gt;<span class="number">2</span>)&#123;</span><br><span class="line">            Thread.yield();</span><br><span class="line">        &#125;</span><br><span class="line">        System.out.println(num);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line">运行结果：</span><br><span class="line"><span class="number">10000</span></span><br></pre></td></tr></table></figure><p>这些类的底层都直接和操作系统挂钩！在内存中修改值，Unsafe类是一个很特殊的存在。</p><p><img src= "/img/loading.gif" data-lazy-src="https://cdn.jsdelivr.net/gh/my-zhb/CDN/img/20201222163634.png"></p><blockquote><p>什么是指令重排</p></blockquote><p>好比你写的代码，计算机并不是按照你写的代码的顺序去执行的。</p><p>源代码—&gt;&gt;编译器优化重排—&gt;&gt;指令并行也可能重排—&gt;&gt;内存系统也会重排—&gt;&gt;执行</p><p><code>volatile</code>可以避免指令重排</p><p>内存屏障，CPU指令。作用：</p><p>1、保证特定的操作的执行顺序！</p><p>2、可以保证某些变量的内存可见性。(利用这些特性volatile就可以实现可见性)</p><p><code>加了volatile关键字的操作，都会在上方和下方形成一个屏障来保证代码的顺序，防止指令重排</code></p><blockquote><p>总结</p></blockquote><p>Volatile可以保证可见性，不能保证原子性，由于内存屏障，可以避免指令重排的现象产生！</p><p>Volatile在单例模式中使用的最多。</p><h1 id="单例模式"><a href="#单例模式" class="headerlink" title="单例模式"></a>单例模式</h1><blockquote><p>饿汉式</p></blockquote><p><code>可能会出现浪费内存的现象，因为程序一启动，就加载了</code></p><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Hungry</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">private</span> <span class="title">Hungry</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">final</span>  <span class="keyword">static</span> Hungry HUNGRY = <span class="keyword">new</span> Hungry();</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> Hungry <span class="title">getInstance</span><span class="params">()</span></span>&#123;</span><br><span class="line">        <span class="keyword">return</span> HUNGRY;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><blockquote><p>懒汉式</p></blockquote><p><code>懒汉式在单线程下是安全的，但是在多线程下是不安全的</code></p><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Lazy</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">private</span> <span class="title">Lazy</span><span class="params">()</span></span>&#123;</span><br><span class="line">        </span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">static</span> Lazy lazy;</span><br><span class="line">    </span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> Lazy <span class="title">getInstance</span><span class="params">()</span></span>&#123;</span><br><span class="line">        <span class="keyword">if</span>(lazy == <span class="keyword">null</span>)&#123;</span><br><span class="line">            lazy = <span class="keyword">new</span> Lazy();</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> lazy;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><blockquote><p>双重校验锁(DCL懒汉)</p></blockquote><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Lazy</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">private</span> <span class="title">Lazy</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">//此处要加volatile，来保证原子性</span></span><br><span class="line">    <span class="comment">// lazy = new Lazy();创建的时候会出现指令重排</span></span><br><span class="line">   <span class="comment">//如果不加会出现以下情况：比如a线程正在创建，还没有创建好，b现在就来了，lazy == null判断就不会是空</span></span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">volatile</span> <span class="keyword">static</span> Lazy lazy;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> Lazy <span class="title">getInstance</span><span class="params">()</span></span>&#123;</span><br><span class="line">        <span class="keyword">if</span>(lazy == <span class="keyword">null</span>)&#123;</span><br><span class="line">            <span class="keyword">synchronized</span>(Lazy.class)&#123;</span><br><span class="line">                <span class="keyword">if</span>(lazy == <span class="keyword">null</span>)&#123;</span><br><span class="line">                    <span class="comment">//不是一个原子性操作</span></span><br><span class="line">                    lazy = <span class="keyword">new</span> Lazy();</span><br><span class="line">                     <span class="comment">/**</span></span><br><span class="line"><span class="comment">                     * 创建对象的过程</span></span><br><span class="line"><span class="comment">                     * 1、分配内存空间</span></span><br><span class="line"><span class="comment">                     * 2、执行构造方法，初始化对象</span></span><br><span class="line"><span class="comment">                     * 3、把这个对象指向这个空间</span></span><br><span class="line"><span class="comment">                     */</span></span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> lazy;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><blockquote><p>静态内部类</p></blockquote><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Holder</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">private</span> <span class="title">Holder</span><span class="params">()</span></span>&#123;</span><br><span class="line">        </span><br><span class="line">    &#125;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> Holder <span class="title">getInstance</span><span class="params">()</span></span>&#123;</span><br><span class="line">        <span class="keyword">return</span> InnerClass.HOLDER;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="class"><span class="keyword">class</span> <span class="title">InnerClass</span></span>&#123;</span><br><span class="line">        <span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">final</span> Holder HOLDER = <span class="keyword">new</span> Holder();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><blockquote><p>单例模式是能被破坏的—&gt;&gt;枚举除外</p></blockquote><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Test</span></span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> <span class="keyword">throws</span> NoSuchMethodException, IllegalAccessException, InvocationTargetException, InstantiationException </span>&#123;</span><br><span class="line">        Lazy lazy1 = Lazy.getInstance();</span><br><span class="line">        <span class="comment">//获取对象类的构造器</span></span><br><span class="line">        Constructor&lt;Lazy&gt; constructor = Lazy.class.getDeclaredConstructor(<span class="keyword">null</span>);</span><br><span class="line">        <span class="comment">//破环其私有方法</span></span><br><span class="line">        constructor.setAccessible(<span class="keyword">true</span>);</span><br><span class="line">        Lazy lazy2 = constructor.newInstance();</span><br><span class="line">        System.out.println(lazy1.hashCode());</span><br><span class="line">        System.out.println(lazy2.hashCode());</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><blockquote><p>枚举也是单例模式—&gt;&gt;不会被反射破坏</p></blockquote><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">enum</span> <span class="title">EnumSigle</span> </span>&#123;</span><br><span class="line">    INSTANCE;</span><br><span class="line">    </span><br><span class="line">    <span class="function"><span class="keyword">public</span> EnumSigle <span class="title">getInstance</span><span class="params">()</span></span>&#123;</span><br><span class="line">        <span class="keyword">return</span> INSTANCE;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>EnumSigle的class文件</p><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">package</span> com.se.base.demo;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">enum</span> <span class="title">EnumSigle</span> </span>&#123;</span><br><span class="line">    INSTANCE;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">private</span> <span class="title">EnumSigle</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> EnumSigle <span class="title">getInstance</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> INSTANCE;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>尝试破坏枚举</p><p><code>java.lang.NoSuchMethodException: com.se.base.demo.EnumSigle.&lt;init&gt;()在这个枚举类中没有这个空参构造</code></p><p><code>在EnumSigle的Class文件中出现了空参构造，但是这里报错说没有空参构造</code></p><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Test1</span></span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> <span class="keyword">throws</span> NoSuchMethodException, IllegalAccessException, InvocationTargetException, InstantiationException </span>&#123;</span><br><span class="line">        Constructor&lt;EnumSigle&gt; constructor = EnumSigle.class.getDeclaredConstructor(<span class="keyword">null</span>);</span><br><span class="line">        constructor.setAccessible(<span class="keyword">true</span>);</span><br><span class="line">        EnumSigle enumSigle = constructor.newInstance();</span><br><span class="line">        System.out.println(enumSigle);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">//执行结果</span></span><br><span class="line">Exception in thread <span class="string">&quot;main&quot;</span> java.lang.NoSuchMethodException: com.se.base.demo.EnumSigle.&lt;init&gt;()</span><br><span class="line">at java.lang.Class.getConstructor0(Class.java:<span class="number">3082</span>)</span><br><span class="line">at java.lang.Class.getDeclaredConstructor(Class.java:<span class="number">2178</span>)</span><br><span class="line">at com.se.base.demo.Test1.main(EnumSigle.java:<span class="number">21</span>)</span><br></pre></td></tr></table></figure><p>通过对<code>Constructor.newInstance()</code>的源码分析可得</p><p>如果是个枚举它会报错：<code>Cannot reflectively create enum objects</code></p><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="meta">@CallerSensitive</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> T <span class="title">newInstance</span><span class="params">(Object ... initargs)</span></span></span><br><span class="line"><span class="function">    <span class="keyword">throws</span> InstantiationException, IllegalAccessException,</span></span><br><span class="line"><span class="function">           IllegalArgumentException, InvocationTargetException</span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">if</span> (!override) &#123;</span><br><span class="line">        <span class="keyword">if</span> (!Reflection.quickCheckMemberAccess(clazz, modifiers)) &#123;</span><br><span class="line">            Class&lt;?&gt; caller = Reflection.getCallerClass();</span><br><span class="line">            checkAccess(caller, clazz, <span class="keyword">null</span>, modifiers);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">if</span> ((clazz.getModifiers() &amp; Modifier.ENUM) != <span class="number">0</span>)</span><br><span class="line">        <span class="keyword">throw</span> <span class="keyword">new</span> IllegalArgumentException(<span class="string">&quot;Cannot reflectively create enum objects&quot;</span>);</span><br><span class="line">    ConstructorAccessor ca = constructorAccessor;   <span class="comment">// read volatile</span></span><br><span class="line">    <span class="keyword">if</span> (ca == <span class="keyword">null</span>) &#123;</span><br><span class="line">        ca = acquireConstructorAccessor();</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="meta">@SuppressWarnings(&quot;unchecked&quot;)</span></span><br><span class="line">    T inst = (T) ca.newInstance(initargs);</span><br><span class="line">    <span class="keyword">return</span> inst;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>通过<code>javap -p EnumSigle.class</code>反编译还是出现了空参构造</p><p><img src= "/img/loading.gif" data-lazy-src="https://cdn.jsdelivr.net/gh/my-zhb/CDN/img/20201228151023.png" alt="img"></p><p>通过jad软件对EnumSigle.class进行反编译成java文件查看</p><p><code>jad -sjava EnumSigle.class</code></p><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">Microsoft Windows [版本 10.0.18363.1256]</span><br><span class="line">(c) 2019 Microsoft Corporation。保留所有权利。</span><br><span class="line"></span><br><span class="line">G:\学习\基础\base\target\classes\com\se\base\demo&gt;jad -sjava EnumSigle.class</span><br><span class="line">Parsing EnumSigle.class... Generating EnumSigle.java</span><br></pre></td></tr></table></figure><p>编译过后的java文件，<code>这里我们就可以看到一个有参的构造器了</code></p><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="comment">// Decompiled by Jad v1.5.8g. Copyright 2001 Pavel Kouznetsov.</span></span><br><span class="line"><span class="comment">// Jad home page: http://www.kpdus.com/jad.html</span></span><br><span class="line"><span class="comment">// Decompiler options: packimports(3) </span></span><br><span class="line"><span class="comment">// Source File Name:   EnumSigle.java</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">package</span> com.se.base.demo;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">final</span> <span class="class"><span class="keyword">class</span> <span class="title">EnumSigle</span> <span class="keyword">extends</span> <span class="title">Enum</span></span></span><br><span class="line"><span class="class"></span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> EnumSigle[] values()</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="keyword">return</span> (EnumSigle[])$VALUES.clone();</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> EnumSigle <span class="title">valueOf</span><span class="params">(String name)</span></span></span><br><span class="line"><span class="function">    </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> (EnumSigle)Enum.valueOf(com/se/base/demo/EnumSigle, name);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">private</span> <span class="title">EnumSigle</span><span class="params">(String s, <span class="keyword">int</span> i)</span></span></span><br><span class="line"><span class="function">    </span>&#123;</span><br><span class="line">        <span class="keyword">super</span>(s, i);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> EnumSigle <span class="title">getInstance</span><span class="params">()</span></span></span><br><span class="line"><span class="function">    </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> INSTANCE;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">final</span> EnumSigle INSTANCE;</span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">final</span> EnumSigle $VALUES[];</span><br><span class="line"></span><br><span class="line">    <span class="keyword">static</span> </span><br><span class="line">    &#123;</span><br><span class="line">        INSTANCE = <span class="keyword">new</span> EnumSigle(<span class="string">&quot;INSTANCE&quot;</span>, <span class="number">0</span>);</span><br><span class="line">        $VALUES = (<span class="keyword">new</span> EnumSigle[] &#123;</span><br><span class="line">            INSTANCE</span><br><span class="line">        &#125;);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure><p><code>重新进行破坏</code></p><p>这次的报错信息符合预期</p><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Test1</span></span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> <span class="keyword">throws</span> NoSuchMethodException, IllegalAccessException, InvocationTargetException, InstantiationException </span>&#123;</span><br><span class="line">        Constructor&lt;EnumSigle&gt; constructor = EnumSigle.class.getDeclaredConstructor(String.class,<span class="keyword">int</span>.class);</span><br><span class="line">        constructor.setAccessible(<span class="keyword">true</span>);</span><br><span class="line">        EnumSigle enumSigle = constructor.newInstance();</span><br><span class="line">        System.out.println(enumSigle);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">//执行结果 </span></span><br><span class="line"><span class="comment">//无法以反射方式创建枚举对象</span></span><br><span class="line">Exception in thread <span class="string">&quot;main&quot;</span> java.lang.IllegalArgumentException: Cannot reflectively create <span class="class"><span class="keyword">enum</span> <span class="title">objects</span></span></span><br><span class="line">at java.lang.reflect.Constructor.newInstance(Constructor.java:417)</span><br><span class="line">at com.se.base.demo.Test1.main(EnumSigle.java:<span class="number">23</span>)</span><br></pre></td></tr></table></figure><h1 id="CAS"><a href="#CAS" class="headerlink" title="CAS"></a>CAS</h1><blockquote><p>什么是CAS</p></blockquote><p>比较当前工作内存中的值和主内存中的值，如果满足期望就执行操作，如果不是就一直循环！</p><blockquote><p>java层面的cas–&gt;compareAndSet</p></blockquote><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Test1</span> </span>&#123;</span><br><span class="line">    <span class="comment">//CAS compareAndSet:比较并交换！</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line">        AtomicInteger atomicInteger = <span class="keyword">new</span> AtomicInteger(<span class="number">2000</span>);</span><br><span class="line">        <span class="comment">//期望、更新,如果满足2000，就跟新成2001</span></span><br><span class="line">        <span class="comment">//否则不更新</span></span><br><span class="line">        atomicInteger.compareAndSet(<span class="number">2000</span>, <span class="number">2001</span>);</span><br><span class="line">        System.out.println(atomicInteger.get());</span><br><span class="line">        System.out.println(atomicInteger.compareAndSet(<span class="number">2000</span>, <span class="number">2002</span>));</span><br><span class="line">        System.out.println(atomicInteger.get());</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><code>compareAndSet底层代码</code></p><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">final</span> <span class="keyword">boolean</span> <span class="title">compareAndSet</span><span class="params">(<span class="keyword">int</span> expect, <span class="keyword">int</span> update)</span> </span>&#123;</span><br><span class="line">   <span class="keyword">return</span> unsafe.compareAndSwapInt(<span class="keyword">this</span>, valueOffset, expect, update);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><code>java无法操作内存需要通过native调用C++去操作内存，Java还可以通过Unsafe这个类去操作内存</code></p><p><img src= "/img/loading.gif" data-lazy-src="https://cdn.jsdelivr.net/gh/my-zhb/CDN/img/20201228165428.png" alt="image-20201228165426843"></p><p><code>unsafe.compareAndSwapInt(this, valueOffset, expect, update)</code></p><p>标准的自旋锁，不满足就一直执行</p><p><img src= "/img/loading.gif" data-lazy-src="https://cdn.jsdelivr.net/gh/my-zhb/CDN/img/20201228170728.png" alt="image-20201228170726744"></p><blockquote><p>CAS优缺点</p></blockquote><p>缺点：</p><ul><li>底层是自旋锁，循环会耗时</li><li>一次性只能保证一个共享变量的原子性</li><li>会出现ABA问题</li></ul><blockquote><p>ABA问题</p></blockquote><p>ABA问题就像西游记里面的真假葫芦一样，真的已经被人掉包了，而他自己还傻傻分不清。</p><p><img src= "/img/loading.gif" data-lazy-src="https://cdn.jsdelivr.net/gh/my-zhb/CDN/img/20201228174652.png"></p><h1 id="原子引用"><a href="#原子引用" class="headerlink" title="原子引用"></a>原子引用</h1><blockquote><p>什么是原子引用</p></blockquote><p>带有版本号的原子操作，称之为原子引用</p><p><code>AtomicReference</code>不带标记的原子引用</p><p><code>AtomicStampedReference</code>带标记的原子引用</p><blockquote><p>原子引用可以解决ABA问题，对应的思想就是乐观锁</p></blockquote><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">CasDemo</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line">        AtomicStampedReference&lt;Integer&gt; stampedReference = <span class="keyword">new</span> AtomicStampedReference&lt;Integer&gt;(<span class="number">10</span>,<span class="number">1</span>);</span><br><span class="line">        <span class="keyword">new</span> Thread(() -&gt; &#123;</span><br><span class="line">            <span class="comment">//获取到标识</span></span><br><span class="line">            <span class="keyword">int</span> stamp = stampedReference.getStamp();</span><br><span class="line">            System.out.println(<span class="string">&quot;A1==&gt;&gt;&quot;</span>+stamp);</span><br><span class="line">            <span class="comment">//休眠2秒</span></span><br><span class="line">            <span class="keyword">try</span> &#123;</span><br><span class="line">                TimeUnit.SECONDS.sleep(<span class="number">2</span>);</span><br><span class="line">            &#125; <span class="keyword">catch</span> (InterruptedException e) &#123;</span><br><span class="line">                e.printStackTrace();</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="comment">//如果满足就更换，并且修改标识值</span></span><br><span class="line">            <span class="comment">//stampedReference.compareAndSet(预期值，替换的值，获取当前标识值，更换的标示值)</span></span><br><span class="line">            <span class="keyword">boolean</span> value1 = stampedReference.compareAndSet(<span class="number">10</span>, <span class="number">11</span>, stampedReference.getStamp(), stampedReference.getStamp() + <span class="number">1</span>);</span><br><span class="line">            <span class="comment">//输出操作是否执行成功</span></span><br><span class="line">            System.out.println(<span class="string">&quot;A2操作==&gt;&gt;&quot;</span>+value1);</span><br><span class="line">            <span class="comment">//输出此时的标识值</span></span><br><span class="line">            System.out.println(<span class="string">&quot;A2==&gt;&gt;&quot;</span>+stampedReference.getStamp());</span><br><span class="line">            <span class="comment">//和上面同理</span></span><br><span class="line">            <span class="keyword">boolean</span> value2 = stampedReference.compareAndSet(<span class="number">11</span>,<span class="number">10</span>,stampedReference.getStamp(),stampedReference.getStamp()+<span class="number">1</span>);</span><br><span class="line">            <span class="comment">//输出操作是否执行成功</span></span><br><span class="line">            System.out.println(<span class="string">&quot;A3操作==&gt;&gt;&quot;</span>+value2);</span><br><span class="line">            System.out.println(<span class="string">&quot;A3==&gt;&gt;&quot;</span>+stampedReference.getStamp());</span><br><span class="line">        &#125;,<span class="string">&quot;A&quot;</span>).start();</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">        <span class="keyword">new</span> Thread(() -&gt; &#123;</span><br><span class="line">            <span class="comment">//获取到标识</span></span><br><span class="line">            <span class="keyword">int</span> stamp = stampedReference.getStamp();</span><br><span class="line">            System.out.println(<span class="string">&quot;B1==&gt;&gt;&quot;</span>+stamp);</span><br><span class="line">            <span class="comment">//休眠2秒</span></span><br><span class="line">            <span class="keyword">try</span> &#123;</span><br><span class="line">                TimeUnit.SECONDS.sleep(<span class="number">2</span>);</span><br><span class="line">            &#125; <span class="keyword">catch</span> (InterruptedException e) &#123;</span><br><span class="line">                e.printStackTrace();</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="comment">//因为这里的标识值已经发生变化了，所以这里会输出false</span></span><br><span class="line">            <span class="keyword">boolean</span> value = stampedReference.compareAndSet(<span class="number">10</span>, <span class="number">111</span>, stamp, stamp + <span class="number">1</span>);</span><br><span class="line">            <span class="comment">//输出操作是否执行成功</span></span><br><span class="line">            System.out.println(<span class="string">&quot;B2操作==&gt;&gt;&quot;</span>+value);</span><br><span class="line">            System.out.println(<span class="string">&quot;B2==&gt;&gt;&quot;</span>+stampedReference.getStamp());</span><br><span class="line">        &#125;,<span class="string">&quot;B&quot;</span>).start();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">//执行结果</span></span><br><span class="line">A1==&gt;&gt;<span class="number">1</span></span><br><span class="line">B1==&gt;&gt;<span class="number">1</span></span><br><span class="line">A2操作==&gt;&gt;<span class="keyword">true</span></span><br><span class="line">A2==&gt;&gt;<span class="number">2</span></span><br><span class="line">A3操作==&gt;&gt;<span class="keyword">true</span></span><br><span class="line">A3==&gt;&gt;<span class="number">3</span></span><br><span class="line">B2操作==&gt;&gt;<span class="keyword">false</span></span><br><span class="line">B2==&gt;&gt;<span class="number">3</span></span><br></pre></td></tr></table></figure><h1 id="锁的理解"><a href="#锁的理解" class="headerlink" title="锁的理解"></a>锁的理解</h1><blockquote><p>公平锁、非公平锁</p></blockquote><p>公平锁：是非常公平的，它不允许插队，必须排队。</p><p>非公平锁：是不公平的，它允许查询，锁默认值都是非公平的。</p><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="comment">//Lock默认创建的是非公平锁</span></span><br><span class="line">   <span class="function"><span class="keyword">public</span> <span class="title">ReentrantLock</span><span class="params">()</span> </span>&#123;</span><br><span class="line">       sync = <span class="keyword">new</span> NonfairSync();</span><br><span class="line">   &#125;</span><br><span class="line"><span class="comment">//方法重载 可以通过参数来控制创建的是公平锁还是非公平锁</span></span><br><span class="line">   <span class="function"><span class="keyword">public</span> <span class="title">ReentrantLock</span><span class="params">(<span class="keyword">boolean</span> fair)</span> </span>&#123;</span><br><span class="line">       sync = fair ? <span class="keyword">new</span> FairSync() : <span class="keyword">new</span> NonfairSync();</span><br><span class="line">   &#125;</span><br></pre></td></tr></table></figure><blockquote><p>可重入锁（递归锁）</p></blockquote><p>个人理解：锁中锁，如果获取到外面的锁，那么里面的锁也自动获取。</p><p>synchronized版本</p><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Demo1</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line">        Home1 home1 = <span class="keyword">new</span> Home1();</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">1</span>; i &lt;= <span class="number">5</span>; i++) &#123;</span><br><span class="line">            <span class="keyword">new</span> Thread(() -&gt; &#123;</span><br><span class="line">                home1.getIntoHome(<span class="string">&quot;张三&quot;</span>+Thread.currentThread().getName());</span><br><span class="line">            &#125;,String.valueOf(i)).start();</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">//家</span></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Home1</span></span>&#123;</span><br><span class="line">    <span class="comment">//进入家</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">synchronized</span> <span class="keyword">void</span>  <span class="title">getIntoHome</span><span class="params">(String name)</span></span>&#123;</span><br><span class="line">        System.out.println(name+<span class="string">&quot;回家&quot;</span>);</span><br><span class="line">        getIntoBedroom(name);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">//进入卧室</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">synchronized</span> <span class="keyword">void</span> <span class="title">getIntoBedroom</span><span class="params">(String name)</span></span>&#123;</span><br><span class="line">        System.out.println(name+<span class="string">&quot;进入卧室&quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">//执行结果</span></span><br><span class="line">张三<span class="number">1</span>回家</span><br><span class="line">张三<span class="number">1</span>进入卧室</span><br><span class="line">张三<span class="number">5</span>回家</span><br><span class="line">张三<span class="number">5</span>进入卧室</span><br><span class="line">张三<span class="number">2</span>回家</span><br><span class="line">张三<span class="number">2</span>进入卧室</span><br><span class="line">张三<span class="number">3</span>回家</span><br><span class="line">张三<span class="number">3</span>进入卧室</span><br><span class="line">张三<span class="number">4</span>回家</span><br><span class="line">张三<span class="number">4</span>进入卧室</span><br></pre></td></tr></table></figure><p>Lock版本</p><p><code>Lock锁必须配对，不然就会出现死锁现象，一个lock.lock()就必须要有一个lock.unlock()</code></p><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Demo1</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line">        Home1 home1 = <span class="keyword">new</span> Home1();</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">1</span>; i &lt;= <span class="number">5</span>; i++) &#123;</span><br><span class="line">            <span class="keyword">new</span> Thread(() -&gt; &#123;</span><br><span class="line">                home1.getIntoHome(<span class="string">&quot;张三&quot;</span>+Thread.currentThread().getName());</span><br><span class="line">            &#125;,String.valueOf(i)).start();</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">//家</span></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Home1</span></span>&#123;</span><br><span class="line">    Lock lock = <span class="keyword">new</span> ReentrantLock();</span><br><span class="line">    <span class="comment">//进入家</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span>  <span class="keyword">void</span>  <span class="title">getIntoHome</span><span class="params">(String name)</span></span>&#123;</span><br><span class="line">        lock.lock();<span class="comment">//此处会拿到一把锁</span></span><br><span class="line">        <span class="keyword">try</span> &#123;</span><br><span class="line">            System.out.println(name+<span class="string">&quot;回家&quot;</span>);</span><br><span class="line">            <span class="comment">//这里也会拿到对应方法的那把锁</span></span><br><span class="line">            getIntoBedroom(name);</span><br><span class="line">        &#125;<span class="keyword">catch</span> (Exception e)&#123;</span><br><span class="line">            e.getMessage();</span><br><span class="line">        &#125;<span class="keyword">finally</span> &#123;</span><br><span class="line">            lock.unlock();</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">//进入卧室</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span>  <span class="keyword">void</span> <span class="title">getIntoBedroom</span><span class="params">(String name)</span></span>&#123;</span><br><span class="line">        lock.lock();</span><br><span class="line">        <span class="keyword">try</span> &#123;</span><br><span class="line">            System.out.println(name+<span class="string">&quot;进入卧室&quot;</span>);</span><br><span class="line">        &#125;<span class="keyword">catch</span> (Exception e)&#123;</span><br><span class="line">            e.getMessage();</span><br><span class="line">        &#125;<span class="keyword">finally</span> &#123;</span><br><span class="line">            lock.unlock();</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">//执行结果</span></span><br><span class="line">张三<span class="number">2</span>回家</span><br><span class="line">张三<span class="number">2</span>进入卧室</span><br><span class="line">张三<span class="number">4</span>回家</span><br><span class="line">张三<span class="number">4</span>进入卧室</span><br><span class="line">张三<span class="number">1</span>回家</span><br><span class="line">张三<span class="number">1</span>进入卧室</span><br><span class="line">张三<span class="number">5</span>回家</span><br><span class="line">张三<span class="number">5</span>进入卧室</span><br><span class="line">张三<span class="number">3</span>回家</span><br><span class="line">张三<span class="number">3</span>进入卧室</span><br></pre></td></tr></table></figure><blockquote><p>自旋锁</p></blockquote><p><code>自旋锁就是不满足条件就一直执行，直到满足条件为止</code></p><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">SpinLock</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="comment">//string默认为空</span></span><br><span class="line">    AtomicReference&lt;String&gt; atomicReference = <span class="keyword">new</span> AtomicReference&lt;String&gt;();</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">lock</span><span class="params">()</span></span>&#123;</span><br><span class="line">        String name = Thread.currentThread().getName();</span><br><span class="line">        System.out.println(name+<span class="string">&quot;加锁中.... &quot;</span>);</span><br><span class="line">        <span class="keyword">do</span> &#123;</span><br><span class="line"></span><br><span class="line">        &#125;<span class="keyword">while</span> (!atomicReference.compareAndSet(<span class="keyword">null</span>,<span class="string">&quot;哈哈&quot;</span>));</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">unlock</span><span class="params">()</span></span>&#123;</span><br><span class="line">        String name = Thread.currentThread().getName();</span><br><span class="line">        System.out.println(name+<span class="string">&quot;解锁中....&quot;</span>);</span><br><span class="line">        atomicReference.compareAndSet(<span class="string">&quot;哈哈&quot;</span>,<span class="keyword">null</span>);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Test</span></span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> <span class="keyword">throws</span> InterruptedException </span>&#123;</span><br><span class="line">        SpinLock spinLock = <span class="keyword">new</span> SpinLock();</span><br><span class="line">        <span class="keyword">new</span> Thread(() -&gt; &#123;</span><br><span class="line">            spinLock.lock();</span><br><span class="line">            <span class="keyword">try</span> &#123;</span><br><span class="line">                <span class="comment">//随眠3秒</span></span><br><span class="line">               TimeUnit.SECONDS.sleep(<span class="number">3</span>);</span><br><span class="line">            &#125;<span class="keyword">catch</span> (Exception e)&#123;</span><br><span class="line">                e.getMessage();</span><br><span class="line">            &#125;<span class="keyword">finally</span> &#123;</span><br><span class="line">                spinLock.unlock();</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;,<span class="string">&quot;A&quot;</span>).start();</span><br><span class="line">        <span class="comment">//休眠1秒 保证A线程先加锁</span></span><br><span class="line">        TimeUnit.SECONDS.sleep(<span class="number">1</span>);</span><br><span class="line">        <span class="keyword">new</span> Thread(() -&gt; &#123;</span><br><span class="line">            spinLock.lock();</span><br><span class="line">            <span class="keyword">try</span> &#123;</span><br><span class="line">                <span class="comment">//随眠1秒</span></span><br><span class="line">                TimeUnit.SECONDS.sleep(<span class="number">1</span>);</span><br><span class="line">            &#125;<span class="keyword">catch</span> (Exception e)&#123;</span><br><span class="line">                e.getMessage();</span><br><span class="line">            &#125;<span class="keyword">finally</span> &#123;</span><br><span class="line">                spinLock.unlock();</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;,<span class="string">&quot;B&quot;</span>).start();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">//执行结果</span></span><br><span class="line">A加锁中.... </span><br><span class="line">B加锁中.... </span><br><span class="line">A解锁中....</span><br><span class="line">B解锁中....</span><br></pre></td></tr></table></figure><blockquote><p>死锁</p></blockquote><p>死锁就是多条线程想去操作同一资源</p><p><img src= "/img/loading.gif" data-lazy-src="https://cdn.jsdelivr.net/gh/my-zhb/CDN/img/20201229170446.png"></p><p>死锁产生的条件:</p><ul><li><strong>互斥条件：</strong>资源是独占的且排他使用，进程互斥使用资源，即任意时刻一个资源只能给一个进程使用，其他进程若申请一个资源，而该资源被另一进程占有时，则申请者等待直到资源被占有者释放。</li><li><strong>不可剥夺条件：</strong>进程所获得的资源在未使用完毕之前，不被其他进程强行剥夺，而只能由获得该资源的进程资源释放。</li><li><strong>请求和保持条件：</strong>进程每次申请它所需要的一部分资源，在申请新的资源的同时，继续占用已分配到的资源。</li><li><strong>循环等待条件：</strong>在发生死锁时必然存在一个进程等待队列{P1,P2,…,P<br>n},其中P1等待P2占有的资源，P2等待P3占有的资源，…，Pn等待P1占有的资源，形成一个进程等待环路，环路中每一个进程所占有的资源同时被另一个申请，也就是前一个进程占有后一个进程所深情地资源。<br>以上给出了导致死锁的四个必要条件，只要系统发生死锁则以上四个条件至少有一个成立。事实上<strong>循环等待</strong>的成立蕴含了前三个条件的成立，似乎没有必要列出然而考虑这些条件对死锁的预防是有利的，因为可以通过破坏四个条件中的任何一个来预防死锁的发生</li></ul><p>死锁示例</p><figure class="highlight java"><table><tr><td class="code"><pre><span class="line">![<span class="number">2</span>](C:\Users\July\Desktop\图片\<span class="number">2.</span>png)<span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Deadlock</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line">        String lockA = <span class="string">&quot;lockA&quot;</span>;</span><br><span class="line">        String lockB = <span class="string">&quot;lockB&quot;</span>;</span><br><span class="line">        <span class="keyword">new</span> Thread(<span class="keyword">new</span> Dead(lockA,lockB),<span class="string">&quot;T1线程&quot;</span>).start();</span><br><span class="line">        <span class="keyword">new</span> Thread(<span class="keyword">new</span> Dead(lockB,lockA),<span class="string">&quot;T2线程&quot;</span>).start();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Dead</span> <span class="keyword">implements</span> <span class="title">Runnable</span></span>&#123;</span><br><span class="line">    String lockA;</span><br><span class="line">    String lockB;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="title">Dead</span><span class="params">(String lockA, String lockB)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">this</span>.lockA = lockA;</span><br><span class="line">        <span class="keyword">this</span>.lockB = lockB;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">run</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="keyword">synchronized</span> (lockA)&#123;</span><br><span class="line">            System.out.println(Thread.currentThread().getName()+<span class="string">&quot;==&gt;&gt;&quot;</span>+lockA+<span class="string">&quot;尝试获取+&quot;</span>+lockB);</span><br><span class="line">            <span class="comment">//休眠2秒 保证测试正确</span></span><br><span class="line">            <span class="keyword">try</span> &#123;</span><br><span class="line">                TimeUnit.SECONDS.sleep(<span class="number">2</span>);</span><br><span class="line">            &#125; <span class="keyword">catch</span> (InterruptedException e) &#123;</span><br><span class="line">                e.printStackTrace();</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">synchronized</span> (lockB)&#123;</span><br><span class="line"></span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><blockquote><p>排查死锁</p></blockquote><p>1.通过jdk自带的工具命令<code>jps -l</code>排查存活的进程</p><p><img src= "/img/loading.gif" data-lazy-src="https://cdn.jsdelivr.net/gh/my-zhb/CDN/img/20201229165357.png" alt="img"></p><p>2.通过命令<code>jstack 17680(进程号) </code>查询</p><p><img src= "/img/loading.gif" data-lazy-src="https://cdn.jsdelivr.net/gh/my-zhb/CDN/img/20201229170050.png"></p><p>这样就能排查到死锁的信息！</p>]]></content>
    
    
    <summary type="html">juc</summary>
    
    
    
    <category term="Java" scheme="https://my-zhb.github.io/categories/Java/"/>
    
    <category term="se" scheme="https://my-zhb.github.io/categories/Java/se/"/>
    
    
    <category term="juc" scheme="https://my-zhb.github.io/tags/juc/"/>
    
  </entry>
  
  <entry>
    <title>io流</title>
    <link href="https://my-zhb.github.io/2020/12/22/9f27402d.html"/>
    <id>https://my-zhb.github.io/2020/12/22/9f27402d.html</id>
    <published>2020-12-22T12:26:26.000Z</published>
    <updated>2020-12-22T13:20:39.590Z</updated>
    
    <content type="html"><![CDATA[<h2 id="什么是IO流"><a href="#什么是IO流" class="headerlink" title="什么是IO流"></a>什么是IO流</h2><p><img src= "/img/loading.gif" data-lazy-src="https://img-blog.csdnimg.cn/20200925161118214.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3FxXzM2NTE0NzY2,size_16,color_FFFFFF,t_70" alt="image"></p><h1 id="IO流的分类"><a href="#IO流的分类" class="headerlink" title="IO流的分类"></a>IO流的分类</h1><ol><li><p>一种方式是按照流的方向进行分类的（输入流，输出流）</p><p> 以内存作为参照物：</p><ul><li>往内存中去的，叫做输入（Input），或者叫做<code>读（Read）</code></li><li>从内存中出来，叫做输出（Output），或者叫做<code>写（Write)</code></li></ul></li><li><p>另外一种方式是按照读取数据方式不同进行分类：（字节流，字符流）</p><ul><li><p>有的流是按照字节的方式读取数据，一次读取1个字节byte，等同于一次读取8个二进制，这种刘是万能的，什么类型的文件都可以读取。（字节流）</p><p>  例子：</p><p>  ​    假设文本：a中国bc<br>  ​    使用字节流读取：<br>  ​    第一次读取到 a<br>  ​    第二次读取到 中的一半<br>  ​    第三次读取到 中的另外一半</p></li><li><p>有的流是按照字符的方式读取数据，一次读取一个字符，这种流是为了方便读取普通文本而存在的，这种流只能读取本文文件。（字符流）</p><p>  例子：</p><p>  ​    假设文本：a中国bc<br>  ​    使用字节流读取：<br>  ​    第一次读取到 a<br>  ​    第二次读取到 中</p></li></ul></li></ol><h1 id="Java-IO流四大家族"><a href="#Java-IO流四大家族" class="headerlink" title="Java IO流四大家族"></a>Java IO流四大家族</h1><ol><li>java.io.InputStream（字节输入流）</li><li>java.io.OutputStream（字节输出流）</li><li>java.io.Reader（字符输入流）</li><li>java.io.Writer （字符输出流）</li></ol><p><strong>注意：在Java中只要类名以Stream结尾的都是字节流，以Reader或者是Writer结尾的都是字符流</strong></p><blockquote><p>四大家族的都是抽象类（abstract class）</p></blockquote><p>所有流都实现了java.io.Cloaseble接口：</p><ul><li>java.io.Cloaseble接口，都是可以关闭的，都有close()方法</li><li>流毕竟是一个管道，这个是内存和硬盘之间的通道，用完之后一定要关闭，不然会消耗很多资源</li></ul><p>所有流都实现了java.io.Flushable接口：</p><ul><li>实现了java.io.Fulshable接口，都是可以刷新的，都有flush()方法</li><li>输出流在最终输出智慧，一定要记得flush()，刷新一下，这个刷新表示将通道/管道当中剩余未输出的数据强行输出完（清空管道）</li></ul><p>注意：如果没用flush()可以导致丢失数据</p><h1 id="java-io-包下面需要知道的流有16个"><a href="#java-io-包下面需要知道的流有16个" class="headerlink" title="java.io 包下面需要知道的流有16个"></a>java.io 包下面需要知道的流有16个</h1><blockquote><p>文件专属</p></blockquote><ul><li>java.io.FileInputStream (掌握)</li><li>java.io.FileOutputStream (掌握)</li><li>java.io.FileReader</li><li>java.io.Writer</li></ul><blockquote><p>转换流：(将字节流转换成字符流)</p></blockquote><ul><li> java.io.InputStreamReader</li><li> java.io.OutputStreamWriter</li></ul><blockquote><p>缓冲流专属</p></blockquote><ul><li>java.io.BufferedReader</li><li>java.io.BufferedWriter</li><li>java.io.BufferedInputStream</li><li>java.io.BufferedOutputStream</li></ul><blockquote><p>数据流专属</p></blockquote><ul><li>java.io.DataInputStream</li><li> java.io.DataOutputStream</li></ul><blockquote><p>标准输出流</p></blockquote><ul><li>java.io.PrintWriter</li><li>java.io.PrintStream (掌握)</li></ul><blockquote><p>对象专属流</p></blockquote><ul><li>java.io.ObjectInputStream  (掌握)</li><li> java.io.ObjectOutputStream  (掌握)</li></ul><h2 id="文件专属"><a href="#文件专属" class="headerlink" title="文件专属"></a>文件专属</h2><blockquote><p>FileInputStream   (字符输入流)</p></blockquote><p>常用的方法：<br>    avaiable(); 返回剩下多个字节没用读取<br>    skip(); 跳过几个字节不读取  </p><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">FileInputSteamTest</span> </span>&#123;</span><br><span class="line">    <span class="comment">//一个一个字符读取</span></span><br><span class="line">    <span class="comment">//这样读取有缺陷：内存和硬盘交互的太频繁 ，不推荐这样写。</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line">        FileInputStream stream = <span class="keyword">null</span>;</span><br><span class="line">        <span class="keyword">try</span> &#123;</span><br><span class="line">            stream = <span class="keyword">new</span> FileInputStream(<span class="string">&quot;D:\\myiszhb\\记录\\fileInputStream.txt&quot;</span>);</span><br><span class="line">            <span class="keyword">int</span> readData = <span class="number">0</span>;</span><br><span class="line">            <span class="comment">//一个个读取数据，如果返回-1说明没有数据了。</span></span><br><span class="line">            <span class="keyword">while</span> ((readData = stream.read()) != -<span class="number">1</span>)&#123;</span><br><span class="line">                System.out.println(readData);</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;<span class="keyword">catch</span> (IOException e)&#123;</span><br><span class="line">            e.getMessage();</span><br><span class="line">        &#125;<span class="keyword">finally</span> &#123;</span><br><span class="line">            <span class="keyword">if</span>(stream != <span class="keyword">null</span>)&#123;</span><br><span class="line">                <span class="keyword">try</span> &#123;</span><br><span class="line">                    stream.close();</span><br><span class="line">                &#125;<span class="keyword">catch</span> (IOException e)&#123;</span><br><span class="line">                    e.printStackTrace();</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">//通过byte[]数组读取，推荐</span></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> test1 &#123;</span><br><span class="line">        FileInputStream stream = <span class="keyword">null</span>;</span><br><span class="line">        <span class="keyword">try</span> &#123;</span><br><span class="line">            stream = <span class="keyword">new</span> FileInputStream(<span class="string">&quot;D:\\myiszhb\\记录\\fileInputStream.txt&quot;</span>);</span><br><span class="line">            <span class="comment">//定义一个byte[]数组一次读取多个</span></span><br><span class="line">            <span class="comment">//注意这种方法不适用于大数据文件</span></span><br><span class="line">            <span class="keyword">byte</span>[] bytes = <span class="keyword">new</span> <span class="keyword">byte</span>[<span class="number">10</span>];</span><br><span class="line">            <span class="keyword">int</span> red = <span class="number">0</span>;</span><br><span class="line">            <span class="comment">//往byte[]数组中读取数据,如果返回-1说明没有数据了。</span></span><br><span class="line">            <span class="keyword">while</span> ( (red = stream.read(bytes)) != -<span class="number">1</span>)&#123;</span><br><span class="line">                <span class="comment">//byte[]数组转string</span></span><br><span class="line">                System.out.println(<span class="keyword">new</span> String(bytes,<span class="number">0</span>,red));</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;<span class="keyword">catch</span> (IOException e)&#123;</span><br><span class="line">            e.getMessage();</span><br><span class="line">        &#125;<span class="keyword">finally</span> &#123;</span><br><span class="line">            <span class="keyword">if</span>(stream != <span class="keyword">null</span>)&#123;</span><br><span class="line">                <span class="keyword">try</span> &#123;</span><br><span class="line">                    stream.close();</span><br><span class="line">                &#125;<span class="keyword">catch</span> (IOException e)&#123;</span><br><span class="line">                    e.printStackTrace();</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><blockquote><p>FileOutputStream (字符输出流)</p></blockquote><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line">    FileOutputStream outputStream = <span class="keyword">null</span>;</span><br><span class="line">    <span class="keyword">try</span> &#123;</span><br><span class="line">        <span class="comment">//文件没有会自动创建文件，注意如果有文件的话会清空原有的文件</span></span><br><span class="line">        <span class="comment">//outputStream = new FileOutputStream(&quot;D:\\myiszhb\\记录\\copy.txt&quot;);</span></span><br><span class="line">        </span><br><span class="line">        <span class="comment">//文件没有会自动创建文件，第二个参数为true，会在原文件上继续追加内容</span></span><br><span class="line">        outputStream = <span class="keyword">new</span> FileOutputStream(<span class="string">&quot;D:\\myiszhb\\记录\\copy.txt&quot;</span>,<span class="keyword">true</span>);</span><br><span class="line">        <span class="keyword">byte</span>[] value = &#123;<span class="number">97</span>,<span class="number">98</span>,<span class="number">99</span>,<span class="number">100</span>&#125;;</span><br><span class="line">        <span class="comment">//将byte[]数组全部写出！</span></span><br><span class="line">        outputStream.write(value);</span><br><span class="line">        </span><br><span class="line">        <span class="comment">//表示读取0-2下标的数据</span></span><br><span class="line">        <span class="comment">//outputStream.write(value,0,2);</span></span><br><span class="line">        </span><br><span class="line">        <span class="comment">//写完之后，清刷一下管道</span></span><br><span class="line">        outputStream.flush();</span><br><span class="line">    &#125;<span class="keyword">catch</span> (IOException e)&#123;</span><br><span class="line">        e.printStackTrace();</span><br><span class="line">    &#125;<span class="keyword">finally</span> &#123;</span><br><span class="line">        <span class="keyword">if</span>(outputStream!=<span class="keyword">null</span>)&#123;</span><br><span class="line">            <span class="keyword">try</span> &#123;</span><br><span class="line">                outputStream.close();</span><br><span class="line">            &#125;<span class="keyword">catch</span> (IOException e)&#123;</span><br><span class="line">                e.printStackTrace();</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;    </span><br></pre></td></tr></table></figure><blockquote><p>FileReader (文件字符输入流)</p></blockquote><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line">    FileReader reader = <span class="keyword">null</span>;</span><br><span class="line">    <span class="keyword">try</span> &#123;</span><br><span class="line">        <span class="comment">//创建文件字符输入流</span></span><br><span class="line">        reader = <span class="keyword">new</span> FileReader(<span class="string">&quot;D:\\myiszhb\\记录\\fileInputStream.txt&quot;</span>);</span><br><span class="line">        <span class="keyword">char</span>[] chars = <span class="keyword">new</span> <span class="keyword">char</span>[<span class="number">4</span>];</span><br><span class="line">        <span class="keyword">int</span> read = <span class="number">0</span>;</span><br><span class="line">        <span class="comment">//开始读取，如果为-1表示读完了</span></span><br><span class="line">        <span class="keyword">if</span>((read = reader.read(chars)) != -<span class="number">1</span>)&#123;</span><br><span class="line">            System.out.println(<span class="keyword">new</span> String(chars,<span class="number">0</span>,chars.length));</span><br><span class="line">        &#125;</span><br><span class="line">    &#125; <span class="keyword">catch</span> (FileNotFoundException e) &#123;</span><br><span class="line">        e.printStackTrace();</span><br><span class="line">    &#125; <span class="keyword">catch</span> (IOException e) &#123;</span><br><span class="line">        e.printStackTrace();</span><br><span class="line">    &#125; <span class="keyword">finally</span> &#123;</span><br><span class="line">        <span class="keyword">if</span>(reader != <span class="keyword">null</span>)&#123;</span><br><span class="line">            <span class="keyword">try</span> &#123;</span><br><span class="line">                reader.close();</span><br><span class="line">            &#125; <span class="keyword">catch</span> (IOException e) &#123;</span><br><span class="line">                e.printStackTrace();</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;    </span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><blockquote><p>FileWriter (文件字符输出流)</p></blockquote><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line">    FileWriter writer = <span class="keyword">null</span>;</span><br><span class="line">    <span class="keyword">try</span> &#123;</span><br><span class="line">        <span class="comment">//创建文件字符输出流</span></span><br><span class="line">        <span class="comment">//没有文件会自动创建,有文件的话会先清空文件内容 </span></span><br><span class="line">        <span class="comment">//writer = new FileWriter(&quot;D:\\myiszhb\\记录\\fileInputStream1.txt&quot;);</span></span><br><span class="line">        <span class="comment">//没有文件会自动创建,第二个参数为true表示追加内容</span></span><br><span class="line">        writer = <span class="keyword">new</span> FileWriter(<span class="string">&quot;D:\\myiszhb\\记录\\fileInputStream1.txt&quot;</span>,<span class="keyword">true</span>);</span><br><span class="line">        <span class="keyword">char</span>[] value = &#123;<span class="string">&#x27;我&#x27;</span>,<span class="string">&#x27;是&#x27;</span>,<span class="string">&#x27;中&#x27;</span>,<span class="string">&#x27;国&#x27;</span>,<span class="string">&#x27;人&#x27;</span>&#125;;</span><br><span class="line">        <span class="comment">//输出</span></span><br><span class="line">        writer.write(value);</span><br><span class="line">        <span class="comment">//刷新管道</span></span><br><span class="line">        writer.flush();</span><br><span class="line">    &#125; <span class="keyword">catch</span> (IOException e) &#123;</span><br><span class="line">        e.printStackTrace();</span><br><span class="line">    &#125;<span class="keyword">finally</span> &#123;</span><br><span class="line">        <span class="keyword">if</span>(writer != <span class="keyword">null</span>)&#123;</span><br><span class="line">            <span class="keyword">try</span> &#123;</span><br><span class="line">                writer.close();</span><br><span class="line">            &#125; <span class="keyword">catch</span> (IOException e) &#123;</span><br><span class="line">                e.printStackTrace();</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="转换流"><a href="#转换流" class="headerlink" title="转换流"></a>转换流</h2><blockquote><p>InputStreamReader (将字节流转换成字符流)</p></blockquote><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="comment">//字节输入流转成字符输入流</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> <span class="keyword">throws</span> Exception</span>&#123;</span><br><span class="line">    <span class="comment">//字节流</span></span><br><span class="line">    FileInputStream in = <span class="keyword">new</span> FileInputStream(<span class="string">&quot;D:\\myiszhb\\记录\\fileInputStream.txt&quot;</span>);</span><br><span class="line">    </span><br><span class="line">    <span class="comment">//通过InputStreamReader转换流转换成字符流</span></span><br><span class="line">     <span class="comment">//此时in是节点流，inputStreamReader是包装流</span></span><br><span class="line">    InputStreamReader inputStreamReader = <span class="keyword">new</span> InputStreamReader(in);</span><br><span class="line">    </span><br><span class="line">    <span class="comment">//这是个字符缓冲流，这个构造方法只能传一个字符流，不能穿字节流</span></span><br><span class="line">    <span class="comment">//此时inputStreamReader是节点流，bufferedReader是包装流</span></span><br><span class="line">    BufferedReader bufferedReader = <span class="keyword">new</span> BufferedReader(inputStreamReader);</span><br><span class="line">    </span><br><span class="line">    <span class="comment">//关闭最外层</span></span><br><span class="line">    bufferedReader.close();</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><blockquote><p>OutputStreamWriter (将字节输出流转换成字符输出流)</p></blockquote><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="comment">//将字节输出流转换成字符输出流</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> <span class="keyword">throws</span> Exception</span>&#123;</span><br><span class="line">    <span class="comment">//字节流</span></span><br><span class="line">    FileOutputStream outputStream = <span class="keyword">new</span> FileOutputStream(<span class="string">&quot;D:\\myiszhb\\记录\\fileInputStream.txt&quot;</span>);</span><br><span class="line">    </span><br><span class="line">    <span class="comment">//通过OutputStreamWriter转换流转换成字符流</span></span><br><span class="line">    <span class="comment">//此时outputStream是节点流，outputStreamWriter是包装流</span></span><br><span class="line">    OutputStreamWriter outputStreamWriter = <span class="keyword">new</span> OutputStreamWriter(outputStream);</span><br><span class="line">    </span><br><span class="line">    <span class="comment">//这是个字符缓冲流，这个构造方法只能传一个字符流，不能穿字节流</span></span><br><span class="line">    <span class="comment">//此时outputStreamWriter是节点流，bufferedReader是包装流</span></span><br><span class="line">    BufferedWriter bufferedReader = <span class="keyword">new</span> BufferedWriter(outputStreamWriter);</span><br><span class="line">    </span><br><span class="line">    <span class="comment">//关闭最外层</span></span><br><span class="line">    bufferedReader.close();</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="缓冲流专属"><a href="#缓冲流专属" class="headerlink" title="缓冲流专属"></a>缓冲流专属</h2><p><code>带有缓冲的流，不要再去定义char，byte数组去接收了</code></p><ol><li>BufferedReader </li><li>BufferedWriter</li><li>BufferedInputStream</li><li>BufferedOutputStream</li></ol><h2 id="数据流专属"><a href="#数据流专属" class="headerlink" title="数据流专属"></a>数据流专属</h2><blockquote><p>DataInputStream (数据输入流)  </p></blockquote><p><strong>DataOutputStream写的文件，只能通过DataInputStream去读，并且读的时候需要提前知道写入的顺序，必须顺序一致才能取出。</strong></p><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> <span class="keyword">throws</span> Exception</span>&#123;</span><br><span class="line">    <span class="comment">//创建数据输入流</span></span><br><span class="line">    DataInputStream dataInputStream = <span class="keyword">new</span> DataInputStream(<span class="keyword">new</span> FileInputStream(<span class="string">&quot;D:\\myiszhb\\记录\\fileInputStream2&quot;</span>));</span><br><span class="line">    <span class="keyword">int</span>  v1 = dataInputStream.readInt();</span><br><span class="line">    <span class="keyword">boolean</span> v2 = dataInputStream.readBoolean();</span><br><span class="line">    <span class="keyword">double</span> v3 = dataInputStream.readDouble();</span><br><span class="line">    <span class="comment">//关闭流</span></span><br><span class="line">    dataInputStream.close();</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><blockquote><p>DataOutputStream (数据输出流)  </p></blockquote><p>这个流可以将数据连同数据的类型一并写入文件，<code>这个文件不是普通文本文档 无法打开</code></p><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> <span class="keyword">throws</span> Exception </span>&#123;</span><br><span class="line">    <span class="comment">//创建数据输出流</span></span><br><span class="line">    DataOutputStream dataOutputStream = <span class="keyword">new</span> DataOutputStream(<span class="keyword">new</span> FileOutputStream(<span class="string">&quot;D:\\myiszhb\\记录\\fileInputStream2&quot;</span>));</span><br><span class="line">    </span><br><span class="line">    <span class="keyword">int</span>  v1 = <span class="number">100</span>;</span><br><span class="line">    <span class="keyword">boolean</span> v2 = <span class="keyword">false</span>;</span><br><span class="line">    <span class="keyword">double</span> v3 = <span class="number">200L</span>;</span><br><span class="line">    <span class="comment">//写数据</span></span><br><span class="line">    dataOutputStream.writeInt(v1);</span><br><span class="line">    dataOutputStream.writeBoolean(v2);</span><br><span class="line">    dataOutputStream.writeDouble(v3);</span><br><span class="line">    <span class="comment">//关闭流</span></span><br><span class="line">    dataOutputStream.close();</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="标准输出流"><a href="#标准输出流" class="headerlink" title="标准输出流"></a>标准输出流</h2><blockquote><p>PrintStream</p></blockquote><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="comment">//标准输出流</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> <span class="keyword">throws</span> Exception</span>&#123;</span><br><span class="line">    <span class="comment">//标准输出流不再指向控制台，而是指向log文件</span></span><br><span class="line">    PrintStream prinStream = <span class="keyword">new</span> PrintStream(<span class="keyword">new</span> FileOutputStream(<span class="string">&quot;D:\\myiszhb\\记录\\log.txt&quot;</span>,<span class="keyword">true</span>));</span><br><span class="line">    <span class="comment">//修改输出方向，将输出方向修改到log文件</span></span><br><span class="line">    System.setOut(prinStream);        System.out.println(<span class="string">&quot;这是一个测试&quot;</span>);</span><br><span class="line">    System.out.println(<span class="string">&quot;这是二个测试&quot;</span>);</span><br><span class="line">    System.out.println(<span class="string">&quot;这是三个测试&quot;</span>);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="对象专属流"><a href="#对象专属流" class="headerlink" title="对象专属流"></a>对象专属流</h2><blockquote><p>ObjectOutoutStream</p></blockquote><figure class="highlight java"><table><tr><td class="code"><pre><span class="line">注意：</span><br><span class="line">    <span class="number">1.</span> 参与序列化和反序列化的对象，必须实现Serializable接口。</span><br><span class="line">    <span class="number">2.</span> 通过源代码发现，Serializable接口只是一个标识接口，这个接口当中什么代码都没有，起到标识作用，Java虚拟机看到这个类实现了这个接口，可能会对这个类有特殊待遇</span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Test</span></span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[]args)</span> <span class="keyword">throws</span> Exception</span>&#123;</span><br><span class="line">        <span class="comment">//创建java对象</span></span><br><span class="line">        Student student = <span class="keyword">new</span> Student(<span class="number">111</span>,<span class="string">&quot;张三&quot;</span>);</span><br><span class="line">        <span class="comment">//序列化</span></span><br><span class="line">        ObjectOutputStream oos = <span class="keyword">new</span> ObjectOutputStream(<span class="keyword">new</span> File(<span class="string">&quot;D:\\myiszhb\\记录\\student&quot;</span>))</span><br><span class="line">        <span class="comment">//序列化对象</span></span><br><span class="line">        oos.writeObject(student);</span><br><span class="line">        <span class="comment">//刷新</span></span><br><span class="line">        oos.flush();</span><br><span class="line">        <span class="comment">//关闭</span></span><br><span class="line">        oos.close();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Student</span> <span class="keyword">implements</span> <span class="title">Serializable</span></span>&#123;</span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">int</span> no;</span><br><span class="line">    <span class="keyword">private</span> String name;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="title">Student</span><span class="params">()</span></span>&#123;</span><br><span class="line">        </span><br><span class="line">    &#125;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="title">Student</span><span class="params">(<span class="keyword">int</span> no,String name)</span></span>&#123;</span><br><span class="line">        <span class="keyword">this</span>.no = no;</span><br><span class="line">        <span class="keyword">this</span>.name = name;</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    <span class="comment">//get/set 暂时没写...</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><blockquote><p> ObjectInputStream</p></blockquote><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Test</span></span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">mian</span><span class="params">(String[] args)</span></span>&#123;</span><br><span class="line">        <span class="comment">//反序列化</span></span><br><span class="line">        ObjectInputStream ois = <span class="keyword">new</span> ObjectInputStream(<span class="keyword">new</span> File(<span class="string">&quot;D:\\myiszhb\\记录\\student&quot;</span>);</span><br><span class="line">        <span class="comment">//开始反序列化</span></span><br><span class="line">        Object o = ois.readObject();</span><br><span class="line">        <span class="comment">//student对象必须重写toString对象</span></span><br><span class="line">        System.out.println(o.toString());</span><br><span class="line">        <span class="comment">//关闭</span></span><br><span class="line">        ois.close();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><blockquote><p><code>transient</code> 表示<code>游离的</code>，不参与序列化</p></blockquote><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Student</span> <span class="keyword">implements</span> <span class="title">Serializable</span></span>&#123;</span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">int</span> no;</span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">transient</span> String name;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="title">Student</span><span class="params">()</span></span>&#123;</span><br><span class="line">        </span><br><span class="line">    &#125;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="title">Student</span><span class="params">(<span class="keyword">int</span> no,String name)</span></span>&#123;</span><br><span class="line">        <span class="keyword">this</span>.no = no;</span><br><span class="line">        <span class="keyword">this</span>.name = name;</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    <span class="comment">//get/set 暂时没写...</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="IO-Properties"><a href="#IO-Properties" class="headerlink" title="IO+Properties"></a>IO+Properties</h2><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Test</span> </span>&#123;</span><br><span class="line">    <span class="comment">/*</span></span><br><span class="line"><span class="comment">       非常好的一个设计理念：</span></span><br><span class="line"><span class="comment">            以后经常改变的数据，可以单独写道一个文件中，使用程序动态读取。</span></span><br><span class="line"><span class="comment">            将来只需要修改这个文件的内存，java代码不需要改动，不需要重新</span></span><br><span class="line"><span class="comment">            编译，服务器也不需要重启，就可以拿到动态的信息。</span></span><br><span class="line"><span class="comment">        类似于这种机制的文件，被称为配置文件。</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> <span class="keyword">throws</span> Exception</span>&#123;</span><br><span class="line">        <span class="comment">/*</span></span><br><span class="line"><span class="comment">            Properties是一个map集合，key和value都是string类型</span></span><br><span class="line"><span class="comment">            想将user文件中的数据加载到Properties对象当中。</span></span><br><span class="line"><span class="comment">         */</span></span><br><span class="line">        <span class="comment">//创建一个输入流对象</span></span><br><span class="line">        FileReader reader = <span class="keyword">new</span> FileReader(<span class="keyword">new</span> File(<span class="string">&quot;H:\\ce\\user&quot;</span>));</span><br><span class="line">        <span class="comment">//创建一个map集合</span></span><br><span class="line">        Properties properties = <span class="keyword">new</span> Properties();</span><br><span class="line"></span><br><span class="line">        <span class="comment">//调用Properties对象的load方法将文件中的数据加载到map集合当中。</span></span><br><span class="line">        <span class="comment">//文件中的数据顺着管道加载到map集合中，其中等号=左边作为key，右边作为value</span></span><br><span class="line">        properties.load(reader);</span><br><span class="line"></span><br><span class="line">        String name = properties.getProperty(<span class="string">&quot;name&quot;</span>);</span><br><span class="line">        System.out.println(name);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">//user内容</span></span><br><span class="line">name=zhangsan</span><br><span class="line">password=<span class="number">123</span></span><br></pre></td></tr></table></figure>]]></content>
    
    
    <summary type="html">io</summary>
    
    
    
    <category term="Java" scheme="https://my-zhb.github.io/categories/Java/"/>
    
    <category term="se" scheme="https://my-zhb.github.io/categories/Java/se/"/>
    
    
    <category term="io" scheme="https://my-zhb.github.io/tags/io/"/>
    
  </entry>
  
  <entry>
    <title>集合</title>
    <link href="https://my-zhb.github.io/2020/12/16/d366874c.html"/>
    <id>https://my-zhb.github.io/2020/12/16/d366874c.html</id>
    <published>2020-12-16T12:57:55.000Z</published>
    <updated>2020-12-16T13:19:41.228Z</updated>
    
    <content type="html"><![CDATA[<h1 id="什么是集合？有什么用？"><a href="#什么是集合？有什么用？" class="headerlink" title="什么是集合？有什么用？"></a>什么是集合？有什么用？</h1><ol><li>数组其实就是一个集合。集合实际上就是一个容器，可以来容纳其他类型的数据。</li><li>集合不能直接存储基本数据类型，另外集合也不能直接存储Java对象。集合当作存储的都是Java对象的内存地址(引用)。 <figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">注意：</span><br><span class="line">    集合在Java中本身就是一个容器，是一个对象。</span><br><span class="line">    集合中任何时候存储的都是引用。</span><br><span class="line"></span><br><span class="line">list.add(100);&#x2F;&#x2F;属于自动装箱Integer,属于对象</span><br></pre></td></tr></table></figure></li><li>在Java中每一个不同的集合，底层会对应不同的数据结果。往不同的集合中存储元素，等于往不同的数据结构中存储。</li><li>在Java中集合分为两大类：<ol><li>一类是单个方式存储元素，这一类集合的super父接口：java.util.Collection。</li><li>一类是以键值对方式存储元素，这一类集合的super父接口：java.util.Map。</li></ol></li></ol><h1 id="集合的继承结构"><a href="#集合的继承结构" class="headerlink" title="集合的继承结构"></a>集合的继承结构</h1><h2 id="list和set"><a href="#list和set" class="headerlink" title="list和set"></a>list和set</h2><p><img src= "/img/loading.gif" data-lazy-src="https://cdn.jsdelivr.net/gh/my-zhb/CDN/img/20201216210150.png" alt="image"></p><h2 id="Map"><a href="#Map" class="headerlink" title="Map"></a>Map</h2><p><img src= "/img/loading.gif" data-lazy-src="https://cdn.jsdelivr.net/gh/my-zhb/CDN/img/20201216210242.png" alt="image"></p><h2 id="所有集合的实现类"><a href="#所有集合的实现类" class="headerlink" title="所有集合的实现类"></a>所有集合的实现类</h2><ol><li>ArrayList: 底层是数组。</li><li>LinkedList: 底层是双向链表。</li><li>Vector: 底层是数组，线程安全的，效率较低。</li><li>HashSet: 底层是HashMap，放在HashSet集合中的元素等同于放在了HasgMap集合的key部分。</li><li>TreeSet: 底层是TreeMap，放在TreeSet集合中的元素等同于放在了TreeMap集合的key部分。</li><li>HashMap: 底层是哈希表</li><li>HashTable: 底层也是哈希表，只不过线程安全的，效率较低。</li><li>Properties: 是线程安全的，并且key和value只能存储字符串String。</li><li>TreeMap: 底层是二叉树，TreeMap集合的key可以自动按照大小顺序排序。</li></ol><h2 id="List存储集合元素的特点"><a href="#List存储集合元素的特点" class="headerlink" title="List存储集合元素的特点"></a>List存储集合元素的特点</h2><ol><li>有序可重复。  <ol><li>有序：<br> 存进去的顺序和取出来的顺序相同，每一个元素都有下标。</li><li>可重复：<br> 存进去1，可以在存储一个1。</li></ol></li></ol><h2 id="Set-Map-存储集合元素的特点"><a href="#Set-Map-存储集合元素的特点" class="headerlink" title="Set(Map)存储集合元素的特点"></a>Set(Map)存储集合元素的特点</h2><ol><li>无序不可重复<ol><li>无序：<br> 存进去的顺序和取出来的顺序不一定相同，另外Set集合没有下标。</li><li>不可重复：<br> 存进去1，不能在存储一个1。</li></ol></li></ol><h2 id="SortedSet-SortedMap-存储集合元素的特点"><a href="#SortedSet-SortedMap-存储集合元素的特点" class="headerlink" title="SortedSet(SortedMap)存储集合元素的特点"></a>SortedSet(SortedMap)存储集合元素的特点</h2><ol><li>首先是无序不可重复的，但是SortedSet集合中的元素是可排序的<ol><li>无序：<br> 存进去的顺序和取出来的顺序不一定相同，另外Set集合没有下标。</li><li>不可重复：<br> 存进去1，不能在存储一个1。</li><li>可排序：<br> 按照大小顺序排序。</li></ol></li></ol><blockquote><p>备注：Map集合的key，就是一个Set集合。往Set集合中放数据，实际上放到了Map的key部分</p></blockquote><h1 id="Collection-常用的方法"><a href="#Collection-常用的方法" class="headerlink" title="Collection 常用的方法"></a>Collection 常用的方法</h1><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> 关于Java.util.Collection接口的常用方法。</span></span><br><span class="line"><span class="comment"> 1.Collection中能存放什么元素？</span></span><br><span class="line"><span class="comment">    没有使用“泛型”，Collection中可以存储Object的所有类型，</span></span><br><span class="line"><span class="comment">    使用了“泛型”之后，Collection只能存储对于泛型的数据</span></span><br><span class="line"><span class="comment"> 2。Collection常用方法</span></span><br><span class="line"><span class="comment">    1. boolean add(Object e) 向集合添加元素</span></span><br><span class="line"><span class="comment">    2. int size() 获取集合中的元素个数</span></span><br><span class="line"><span class="comment">    3. void clear() 清空集合元素</span></span><br><span class="line"><span class="comment">    4. boolean contains(Object e) 判断集合里面是否包含某个元素</span></span><br><span class="line"><span class="comment">    5. boolean remove(Object e) 删除集合中的某个元素</span></span><br><span class="line"><span class="comment">    6. boolean isEmpty() 判断集合元素个数是否为0</span></span><br><span class="line"><span class="comment">    7. Object[] toArray() 将集合转换成数组</span></span><br><span class="line"><span class="comment">    8. Iterator iterator() 获取集合对象的迭代器对象Iterator</span></span><br><span class="line"><span class="comment">        以下两个方法时迭代器对象Iterator中的方法：</span></span><br><span class="line"><span class="comment">            boolean hasNext() 如果仍有元素可以叠，则返回true</span></span><br><span class="line"><span class="comment">            Object next() 返回迭代的下一个元素</span></span><br><span class="line"><span class="comment">        注意：此时获取的迭代器，指向的是那个集合中没有元素的状态下的迭代器</span></span><br><span class="line"><span class="comment">        注意：集合结果只要发生改变，迭代器必须重写获取</span></span><br><span class="line"><span class="comment">        注意：在集合元素迭代的时候不能调用remove方法。不能调用集合的remove方法，可以调用迭代器的remove方法，因为调用集合的remove方法 它不会通知迭代器，而调用迭代器的remove方法，它会删除集合以及迭代器的元素。</span></span><br><span class="line"><span class="comment">        </span></span><br><span class="line"><span class="comment">        </span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">CollectionTest1</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line">        <span class="comment">/*</span></span><br><span class="line"><span class="comment">         接口时抽象的，无法实例化</span></span><br><span class="line"><span class="comment">         Collection collection = new Collection();</span></span><br><span class="line"><span class="comment">         */</span></span><br><span class="line">        <span class="comment">//多态</span></span><br><span class="line">        Collection c =  <span class="keyword">new</span> ArrayList();</span><br><span class="line">        c.add(<span class="number">100</span>);<span class="comment">//自动装箱机制，实际上时放进去了一个对象的内存地址。Integer integer = new Integer(100)</span></span><br><span class="line">        c.size();</span><br><span class="line">        c.clear();</span><br><span class="line">        c.contains(<span class="string">&quot;a&quot;</span>);</span><br><span class="line">        c.remove(<span class="string">&quot;a&quot;</span>);</span><br><span class="line">        c.isEmpty();</span><br><span class="line">        Object[] objects = c.toArray();</span><br><span class="line">        <span class="comment">//注意：此时获取的迭代器，指向的是那个集合中没有元素的状态下的迭代器</span></span><br><span class="line">        <span class="comment">//集合结果只要发生改变，迭代器必须重写获取</span></span><br><span class="line">        Iterator iterator = c.iterator();</span><br><span class="line">        <span class="keyword">while</span> (iterator.hasNext())&#123;</span><br><span class="line">            Object o = iterator.next();</span><br><span class="line">            System.out.println(o);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h1 id="Map接口中常用方法"><a href="#Map接口中常用方法" class="headerlink" title="Map接口中常用方法"></a>Map接口中常用方法</h1><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="comment">/*</span></span><br><span class="line"><span class="comment">java.util.Map</span></span><br><span class="line"><span class="comment">    1. Map和Collection没有集成关系。</span></span><br><span class="line"><span class="comment">    2. Map集合以key和value的方式存储数据：键值对</span></span><br><span class="line"><span class="comment">        key和value都是引用数据类型。</span></span><br><span class="line"><span class="comment">        key和value都是存储对象的内存地址。</span></span><br><span class="line"><span class="comment">        key起到主导第地位，value是key的一个附属品。</span></span><br><span class="line"><span class="comment">    3. Map接口中常用方法：</span></span><br><span class="line"><span class="comment">        V put(K key,V value) 向Map集合中添加键值对</span></span><br><span class="line"><span class="comment">        V get(Object key) 通过key查询value</span></span><br><span class="line"><span class="comment">        void clear() 清空Map集合</span></span><br><span class="line"><span class="comment">        boolean containsKey(Object key) 判断Map集合是否包含key</span></span><br><span class="line"><span class="comment">        boolean containsVlaue(Object value) 判断Map集合是否包含value</span></span><br><span class="line"><span class="comment">        boolean isEmpty() 判断Map集合中元素个数是否为0（为空）</span></span><br><span class="line"><span class="comment">        Set&lt;K&gt; keySet() 获取Map集合所有的key（所有的键是一个set集合）</span></span><br><span class="line"><span class="comment">        V remove(Object key) 通过key删除Map集合中的元素</span></span><br><span class="line"><span class="comment">        int size() 获取Map集合的个数</span></span><br><span class="line"><span class="comment">        Collection&lt;V&gt; values() 获取Map集合中所有的value，返回一个Collection</span></span><br><span class="line"><span class="comment">        Set&lt;Map.Entry&lt;K,V&gt;&gt; entrySet() 将Map集合转换成Set集合</span></span><br><span class="line"><span class="comment">            假设： map 集合对象的</span></span><br><span class="line"><span class="comment">                 key  value</span></span><br><span class="line"><span class="comment">                 1    zhangsan</span></span><br><span class="line"><span class="comment">             -------------------------------</span></span><br><span class="line"><span class="comment">             转换后： Set set = map.entrySet();</span></span><br><span class="line"><span class="comment">                1=zhangsan  (这是一个值)</span></span><br><span class="line"><span class="comment">             备注：Map集合调用entrySet()方法得到set集合类型是Map.Entry类型的，</span></span><br><span class="line"><span class="comment">             Map.Entry和String一样，都是一种类型的名字，不过Map.Entry是静态内部类</span></span><br><span class="line"><span class="comment">*/</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">MapTest1</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line">        Map&lt;Integer,String&gt; map = <span class="keyword">new</span> HashMap&lt;&gt;();</span><br><span class="line">        map.put(<span class="number">1</span>,<span class="string">&quot;1&quot;</span>);</span><br><span class="line">        map.put(<span class="number">2</span>,<span class="string">&quot;2&quot;</span>);</span><br><span class="line">        map.put(<span class="number">3</span>,<span class="string">&quot;3&quot;</span>);</span><br><span class="line">        <span class="comment">//遍历Map的3种方式</span></span><br><span class="line">        <span class="comment">//1.foreach 先获取所有的key</span></span><br><span class="line">        Set&lt;Integer&gt; integers = map.keySet();</span><br><span class="line">        <span class="keyword">for</span> (Integer integer : integers) &#123;</span><br><span class="line">            System.out.println(integer+<span class="string">&quot;=&quot;</span>+map.get(integer));</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="comment">//2. 通过entrySet()方法转换成set集合 遍历</span></span><br><span class="line">        Set&lt;Map.Entry&lt;Integer, String&gt;&gt; set = map.entrySet();</span><br><span class="line">        <span class="keyword">for</span> (Map.Entry&lt;Integer, String&gt; entry : set) &#123;</span><br><span class="line">            System.out.println(entry.getKey()+<span class="string">&quot;=&quot;</span>+entry.getValue());</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="comment">//3. 通过entrySet()方法转换成set集合,在转换成迭代器,遍历迭代器</span></span><br><span class="line">        Set&lt;Map.Entry&lt;Integer, String&gt;&gt; set1 = map.entrySet();</span><br><span class="line">        Iterator&lt;Map.Entry&lt;Integer, String&gt;&gt; iterator = set1.iterator();</span><br><span class="line">        <span class="keyword">while</span> (iterator.hasNext())&#123;</span><br><span class="line">            Map.Entry&lt;Integer, String&gt; next = iterator.next();<span class="comment">//这里的Map.Entry 实际上就是一个node</span></span><br><span class="line">            System.out.println(next.getKey()+<span class="string">&quot;=&quot;</span>+next.getValue());</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h1 id="List-常用方法"><a href="#List-常用方法" class="headerlink" title="List 常用方法"></a>List 常用方法</h1><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="number">1.</span> List集合存储元素的特点：有序可重复</span><br><span class="line">    <span class="number">1.1</span> 有序，指List集合中的元素有下标。从<span class="number">0</span>开始，依次递增</span><br><span class="line">    <span class="number">1.2</span> 可重复，存储一个<span class="number">1</span>，还可以在存储一个<span class="number">1.</span></span><br><span class="line"><span class="number">2.</span> List既然是Collection接口的子接口，肯定List接口有自己特色的常用方法：</span><br><span class="line">    <span class="number">2.1</span> <span class="function"><span class="keyword">void</span> <span class="title">add</span><span class="params">(<span class="keyword">int</span> index,Object element)</span> 添加元素</span></span><br><span class="line"><span class="function">    2.2 Object <span class="title">get</span><span class="params">(<span class="keyword">int</span> index)</span> 根据下标取元素</span></span><br><span class="line"><span class="function">    2.3 <span class="keyword">int</span> <span class="title">indexOf</span><span class="params">(Object o)</span> 获取指定元素第一次出现的索引</span></span><br><span class="line"><span class="function">    2.4 <span class="keyword">int</span> <span class="title">lastIndexOf</span><span class="params">(Object o)</span> 获取指定元素最后一次出现的索引</span></span><br><span class="line"><span class="function">    2.5 Object <span class="title">remove</span><span class="params">(<span class="keyword">int</span> index)</span> 通过索引删除元素</span></span><br><span class="line"><span class="function">    2.6 Object <span class="title">set</span><span class="params">(<span class="keyword">int</span> index,Object element)</span> 往指定索引添加元素</span></span><br></pre></td></tr></table></figure><h1 id="总结"><a href="#总结" class="headerlink" title="总结"></a><code>总结</code></h1><blockquote><p>ArrayList</p></blockquote><ol><li><p>有序可重复</p></li><li><p>List的初始化容量为10（底层先创建了一个长度为0的数组，当添加第一个元素的时候，初始化容量10）。</p></li><li><p>ArryList集合底层是Object[]数组`。</p></li><li><p>ArryList集合扩容容量是(旧容量+旧容量&gt;&gt;1)，扩容原数组的1.5倍。</p> <figure class="highlight java"><table><tr><td class="code"><pre><span class="line">例如：</span><br><span class="line">    旧容量 = <span class="number">10</span>;</span><br><span class="line">    扩容之后: <span class="number">10</span> + (<span class="number">10</span>&gt;&gt;<span class="number">1</span>) = <span class="number">15</span></span><br><span class="line">    解析：<span class="number">10</span> 的二进制 <span class="number">0000</span> <span class="number">1010</span></span><br><span class="line">    右移后：<span class="number">0000</span> <span class="number">0101</span> 的十进制 <span class="number">4</span>+<span class="number">1</span>=<span class="number">5</span></span><br><span class="line"></span><br><span class="line">add扩容底层源码</span><br><span class="line"><span class="function"><span class="keyword">private</span> <span class="keyword">void</span> <span class="title">grow</span><span class="params">(<span class="keyword">int</span> minCapacity)</span> </span>&#123;</span><br><span class="line">    <span class="comment">// overflow-conscious code</span></span><br><span class="line">    <span class="keyword">int</span> oldCapacity = elementData.length;<span class="comment">//旧的容量</span></span><br><span class="line">    <span class="keyword">int</span> newCapacity = oldCapacity + (oldCapacity &gt;&gt; <span class="number">1</span>);<span class="comment">//扩容后的容量</span></span><br><span class="line">    <span class="keyword">if</span> (newCapacity - minCapacity &lt; <span class="number">0</span>)</span><br><span class="line">        newCapacity = minCapacity;</span><br><span class="line">    <span class="keyword">if</span> (newCapacity - MAX_ARRAY_SIZE &gt; <span class="number">0</span>)</span><br><span class="line">        newCapacity = hugeCapacity(minCapacity);</span><br><span class="line">    <span class="comment">// minCapacity is usually close to size, so this is a win:</span></span><br><span class="line">    elementData = Arrays.copyOf(elementData, newCapacity);<span class="comment">//copy数组</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li><li><p>ArrayList集合非线程安全</p></li><li><p>ArryList的优点：检索效率比较高（因为底层是数组，数组的检索效率高，但是增删操作效率低）。</p></li><li><p>ArryList的缺点：随机增删元素效率较低，但是在末尾增删效率不变。</p></li></ol><blockquote><p>LinkedList</p></blockquote><ol><li>LinkedList集合底层也有下标。</li><li>LinkedList集合没有初始化容量。</li><li>LinkedList集合底层是双向链表。</li><li>LinkedList的优点：由于链表上的元素空间存储地址不连续，所以随机增删元素的时候不会有大量元素位移，因此随机增删效率高</li><li>LinkedList的缺点：不能通过数学表达式查找元素的内存地址，每一次都需要从头节点开始遍历，直到找到为止，所以检索效率较低。</li><li>LinkedList非线程安全。</li><li>有序可重复。</li></ol><blockquote><p>Vector</p></blockquote><ol><li>Vector集合底层也是一个数组。</li><li>Vector集合底层初始容量为10。</li><li>Vector集合的扩容,扩容数后时原数组的2倍大小。</li></ol><figure class="highlight java"><table><tr><td class="code"><pre><span class="line">备注：</span><br><span class="line">    java.utls.Collection 是接口</span><br><span class="line">    java.utls.Collections 是工具类 里面封装了方法用于集合操作</span><br><span class="line">    </span><br><span class="line"><span class="function"><span class="keyword">private</span> <span class="keyword">void</span> <span class="title">grow</span><span class="params">(<span class="keyword">int</span> var1)</span> </span>&#123;</span><br><span class="line">    <span class="comment">//获得数组的长度</span></span><br><span class="line">    <span class="keyword">int</span> var2 = <span class="keyword">this</span>.elementData.length;</span><br><span class="line">    <span class="comment">//capacityIncrement一直为0;</span></span><br><span class="line">    <span class="comment">//数组长度+ （初始长度&gt;0?初始长度：数组长度）</span></span><br><span class="line">    <span class="comment">//默认扩容var2+var2;</span></span><br><span class="line">    <span class="keyword">int</span> var3 = var2 + (<span class="keyword">this</span>.capacityIncrement &gt; <span class="number">0</span> ? <span class="keyword">this</span>.capacityIncrement : var2);</span><br><span class="line">    <span class="keyword">if</span> (var3 - var1 &lt; <span class="number">0</span>) &#123;</span><br><span class="line">        var3 = var1;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">if</span> (var3 - <span class="number">2147483639</span> &gt; <span class="number">0</span>) &#123;</span><br><span class="line">        var3 = hugeCapacity(var1);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">this</span>.elementData = Arrays.copyOf(<span class="keyword">this</span>.elementData, var3);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><ol start="4"><li>Vector集合线程安全，都带有synchronized关键字修饰，效率较低。</li><li>有序可重复。</li></ol><blockquote><p>HashSet</p></blockquote><ol><li>无序不可重复（无序：存进去的顺序和取出来的顺序不同）</li><li>放到HsahSet集合的元素实际是存放到HashMap集合的key部分。</li><li>HashSet集合非线程安全。</li></ol><blockquote><p>HashMap</p></blockquote><ol><li><p>HashMap集合底层是哈希表/散列表的数据结构。  </p></li><li><p>哈希表是一个怎么样的数据结构呢？<br> 哈希表是一个数组和单向链表的结合体。<br> 数组：在查询方面效率很高，随机增删方面效率很低。<br> 单向链表：在查询方法效率低，随机增删方法效率高。<br> 哈希表将数组、单向链表两种数据结构融合在一起，充分发挥它们各自的优点。</p></li><li><p>HashMap集合底层的源代码 </p> <figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">HashMap</span></span>&#123;</span><br><span class="line">    <span class="comment">//HashMap底层实际上就是一个数组。</span></span><br><span class="line">    Node&lt;k,v&gt;[] table;</span><br><span class="line">    <span class="comment">//静态的内部类HashMap.Node</span></span><br><span class="line">    <span class="keyword">static</span> <span class="class"><span class="keyword">class</span> <span class="title">Node</span>&lt;<span class="title">K</span>,<span class="title">V</span>&gt;</span>&#123;</span><br><span class="line">        <span class="keyword">final</span> <span class="keyword">int</span> hash; <span class="comment">//哈希值（哈希值是key通过hashCode()方法的执行结构,hash值通过哈希函数/算法,可转换成数组的下标）</span></span><br><span class="line">        <span class="keyword">final</span> K key; <span class="comment">//存储的Map集合中的key</span></span><br><span class="line">        V value; <span class="comment">//存储到Map集合中的value</span></span><br><span class="line">        Node&lt;K,V&gt; next; <span class="comment">//下一个节点的内存地址</span></span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li><li><p>HashMap集合key的部分特点<br> 无序：存进去和取出来的顺序不同,所以无序。<br> 不可重复：因为底层采用了equals方法来保证HashMap集合的key不可重复,如果可以重复了,value的值会被直接覆盖。<br> HashMap是非线程安全的。<br> 放在HashMap集合key部分的元素其实就是放在了HashSet集合中了。<br> 所以HashSet集合中的元素也需要同时重写hashCode()和equals()方法。</p></li><li><p>哈希表HashMap使用不当时无法发挥性能<br> 我们要保证散列分布均匀，那什么是散列分布均匀呢？  </p><pre><code> 假设有100个元素，10个单向链表，那么么个单向链表上有10个节点，这是最好的，是散列分布均匀的。</code></pre></li><li><p>重点<br> 放在HashMap集合key部分的元素，以及放在HashSet集合中的元素，需要同时重写hashCode()和equals()方法。</p></li><li><p>HashMap集合默认初始容量是16,默认加载因子是0.75f，扩容后的容量是原容量的2倍 。<br> 这个默认加载因子是当HashMap集合底层数组的容量达到75%的时候,数组开始扩容。<br> 重点：HashMap初始容量必须是2的倍数,这是官方推荐的,这样能达到散列均匀,为了提高HashMap集合的存储效率。</p></li><li><p>JDK1.8之后HashMap中哈希表单向链表的数量超过8个就会换成红黑树结构,如果数量小于6就会转换成单向链表结构。</p></li><li><p>map.put(k,v)实现原理<br>第一步：先将k,v封装到Node对象当中。<br>第二步：底层会调用k的hashCode()方法得到hash值,然后通过哈希函数/哈希算法，<br>将hash值转换成数组的下标,下标位置上如果没有任何元素,就把Node添加到这个位置<br>上,如果说下标对于的位置上有链表(Node),此时会拿着k和链表上每一个节点中的k进<br>行equals比较,如果所有的equals方法返回false,那么这个节点将被添加到链表的末<br>尾,如果其中一个equals返回了true,那么这个节点的value将会被覆盖。</p></li><li><p>map.get(k)实现原理<br>先调用k的hansCode()方法得到哈希值,通过哈希算法转换成数组下标,通过数组下标<br>快速找到对应位置上，如果这个位置上面都没有,返回null。如果这个节点上有单向链<br>表(Node),那么会拿着参数k和单向链表上的每个节点中的k进行equals比较,如果所<br>有的equals都返回false,那么get方法返回null。只要其中一个节点返回true,那<br>么此时就会把这个节点上的value,返回回去。</p></li></ol><blockquote><p>HashTable</p></blockquote><ol><li>HashTable集合的底层也是哈希表/散列表结构。</li><li>HashTable集合的初始化容量是11，默认加载因子也是0.75f,扩容量是：(原长度*2)+1</li></ol><blockquote><p>Properties</p></blockquote><ol><li>Properties是一个Map集合，继承HashTable，properties是key和value都是String类型的。</li><li>Properties被称为属性对象。</li><li>Properties是线程安全的。</li></ol><blockquote><p>TreeSet</p></blockquote><ol><li><p>TreeSet集合底层实际上是一个TreeMap</p></li><li><p>TreeMap集合底层是一个二叉树</p></li><li><p>放在TreeSet集合中的元素，等同于放在TreeMap的key部分</p></li><li><p>TreeSet集合中的元素 无序不可重复，但是可以按照元素的大小顺序真的排序，称为：可排序集合。</p></li><li><p>TreeSet集合非线程安全。</p></li><li><p>TreeSet集如果存入自定义对象，自定义对象必须实现Comparable&lt;&gt;接口<br> TreeMap底层源码是先判断有无比较器的。<br> Comparable和Comparator怎么选择？</p><pre><code> 1. 比较规则经常发生改变时，使用Comparator，Comparator接口符合OCP原则。   2. 比较规则不会发生变动时，使用Comparable。</code></pre><p> 方式1：实现java.long.Comparable接口,并重写其compareTo方法。</p> <figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="comment">/*</span></span><br><span class="line"><span class="comment">    User对象按照年龄排序</span></span><br><span class="line"><span class="comment">    如果年龄一样就按照name排序</span></span><br><span class="line"><span class="comment">*/</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">TreeSetTest</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line">        User user1 = <span class="keyword">new</span> User(<span class="number">20</span>,<span class="string">&quot;三毛&quot;</span>);</span><br><span class="line">        User user2 = <span class="keyword">new</span> User(<span class="number">30</span>,<span class="string">&quot;李四&quot;</span>);</span><br><span class="line">        User user3 = <span class="keyword">new</span> User(<span class="number">18</span>,<span class="string">&quot;张三&quot;</span>);</span><br><span class="line">        User user4 = <span class="keyword">new</span> User(<span class="number">20</span>,<span class="string">&quot;阿珂&quot;</span>);</span><br><span class="line">        Set set = <span class="keyword">new</span> TreeSet&lt;User&gt;();</span><br><span class="line">        set.add(user1);</span><br><span class="line">        set.add(user2);</span><br><span class="line">        set.add(user3);</span><br><span class="line">        set.add(user4);</span><br><span class="line">        <span class="keyword">for</span> (Object o : set) &#123;</span><br><span class="line">            System.out.println(o);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">//重点：TreeSet存入自定义对象必须重写Comparable接口,并实现其compareTo方法。</span></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">User</span> <span class="keyword">implements</span> <span class="title">Comparable</span>&lt;<span class="title">User</span>&gt; </span>&#123;</span><br><span class="line">    <span class="keyword">int</span> age;</span><br><span class="line">    String name;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="title">User</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="title">User</span><span class="params">(<span class="keyword">int</span> age, String name)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">this</span>.age = age;</span><br><span class="line">        <span class="keyword">this</span>.name = name;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">int</span> <span class="title">getAge</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> age;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">setAge</span><span class="params">(<span class="keyword">int</span> age)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">this</span>.age = age;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> String <span class="title">getName</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> name;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">setName</span><span class="params">(String name)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">this</span>.name = name;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> String <span class="title">toString</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="keyword">final</span> StringBuffer sb = <span class="keyword">new</span> StringBuffer(<span class="string">&quot;User&#123;&quot;</span>);</span><br><span class="line">        sb.append(<span class="string">&quot;age=&quot;</span>).append(age);</span><br><span class="line">        sb.append(<span class="string">&quot;, name=&#x27;&quot;</span>).append(name).append(<span class="string">&#x27;\&#x27;&#x27;</span>);</span><br><span class="line">        sb.append(<span class="string">&#x27;&#125;&#x27;</span>);</span><br><span class="line">        <span class="keyword">return</span> sb.toString();</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    <span class="comment">/*</span></span><br><span class="line"><span class="comment">        compareTo方法的返回值很重要：</span></span><br><span class="line"><span class="comment">            返回0表示相同，value会覆盖。</span></span><br><span class="line"><span class="comment">            返回&gt;0，会继续在右子树上找。（10-9=1，1&gt;0 说明左边这个数字比较大，所以在右子树上找）</span></span><br><span class="line"><span class="comment">            返回&lt;0，会继续在左子树上找。</span></span><br><span class="line"><span class="comment">    */</span></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">int</span> <span class="title">compareTo</span><span class="params">(User o)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">if</span>(<span class="keyword">this</span>.age == o.getAge())&#123;</span><br><span class="line">            <span class="keyword">return</span> o.getName().compareTo(<span class="keyword">this</span>.getName());</span><br><span class="line">        &#125;<span class="keyword">else</span>&#123;</span><br><span class="line">            <span class="keyword">return</span> <span class="keyword">this</span>.age-o.getAge();</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p> 方式2：创建一个比较器实现java.utls.Comparator接口，并重写的compare方法，然后创建TreeSet集合的时候传入进去</p> <figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">TreeSetTest</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line">        User user1 = <span class="keyword">new</span> User(<span class="number">20</span>,<span class="string">&quot;三毛&quot;</span>);</span><br><span class="line">        User user2 = <span class="keyword">new</span> User(<span class="number">30</span>,<span class="string">&quot;李四&quot;</span>);</span><br><span class="line">        User user3 = <span class="keyword">new</span> User(<span class="number">18</span>,<span class="string">&quot;张三&quot;</span>);</span><br><span class="line">        User user4 = <span class="keyword">new</span> User(<span class="number">20</span>,<span class="string">&quot;阿珂&quot;</span>);</span><br><span class="line">        Set set = <span class="keyword">new</span> TreeSet&lt;User&gt;(<span class="keyword">new</span> UserComparator());</span><br><span class="line">        <span class="comment">//或者使用匿名内部类</span></span><br><span class="line">        <span class="comment">/*</span></span><br><span class="line"><span class="comment">            Set set = new TreeSet&lt;User&gt;(new Comparator&lt;User&gt;()&#123;</span></span><br><span class="line"><span class="comment">                 public int compare(User o1, User o2) &#123;</span></span><br><span class="line"><span class="comment">                    if(o1.getAge() == o2.getAge())&#123;</span></span><br><span class="line"><span class="comment">                        return o2.getName().compareTo(o1.getName());</span></span><br><span class="line"><span class="comment">                    &#125;else&#123;</span></span><br><span class="line"><span class="comment">                        return o1.getAge()-o2.getAge();</span></span><br><span class="line"><span class="comment">                    &#125;</span></span><br><span class="line"><span class="comment">                &#125;</span></span><br><span class="line"><span class="comment">            &#125;);</span></span><br><span class="line"><span class="comment">        */</span></span><br><span class="line">        set.add(user1);</span><br><span class="line">        set.add(user2);</span><br><span class="line">        set.add(user3);</span><br><span class="line">        set.add(user4);</span><br><span class="line">        <span class="keyword">for</span> (Object o : set) &#123;</span><br><span class="line">            System.out.println(o);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">User</span></span>&#123;</span><br><span class="line">    <span class="keyword">int</span> age;</span><br><span class="line">    String name;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="title">User</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="title">User</span><span class="params">(<span class="keyword">int</span> age, String name)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">this</span>.age = age;</span><br><span class="line">        <span class="keyword">this</span>.name = name;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">int</span> <span class="title">getAge</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> age;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">setAge</span><span class="params">(<span class="keyword">int</span> age)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">this</span>.age = age;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> String <span class="title">getName</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> name;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">setName</span><span class="params">(String name)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">this</span>.name = name;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> String <span class="title">toString</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="keyword">final</span> StringBuffer sb = <span class="keyword">new</span> StringBuffer(<span class="string">&quot;User&#123;&quot;</span>);</span><br><span class="line">        sb.append(<span class="string">&quot;age=&quot;</span>).append(age);</span><br><span class="line">        sb.append(<span class="string">&quot;, name=&#x27;&quot;</span>).append(name).append(<span class="string">&#x27;\&#x27;&#x27;</span>);</span><br><span class="line">        sb.append(<span class="string">&#x27;&#125;&#x27;</span>);</span><br><span class="line">        <span class="keyword">return</span> sb.toString();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">//创建比较器实现compare方法，写判断规则</span></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">UserComparator</span> <span class="keyword">implements</span> <span class="title">Comparator</span>&lt;<span class="title">User</span>&gt;</span>&#123;</span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">int</span> <span class="title">compare</span><span class="params">(User o1, User o2)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">if</span>(o1.getAge() == o2.getAge())&#123;</span><br><span class="line">            <span class="keyword">return</span> o2.getName().compareTo(o1.getName());</span><br><span class="line">        &#125;<span class="keyword">else</span>&#123;</span><br><span class="line">            <span class="keyword">return</span> o1.getAge()-o2.getAge();</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li></ol><h1 id="源码分析"><a href="#源码分析" class="headerlink" title="源码分析"></a>源码分析</h1><h2 id="Collection的方法：-boolean-contains-Object-e"><a href="#Collection的方法：-boolean-contains-Object-e" class="headerlink" title="Collection的方法： boolean contains(Object e)"></a>Collection的方法： boolean contains(Object e)</h2><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">CollectionTest3</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line">        Collection c = <span class="keyword">new</span> ArrayList();</span><br><span class="line">        String s1 = <span class="keyword">new</span> String(<span class="string">&quot;abc&quot;</span>);</span><br><span class="line">        c.add(s1);</span><br><span class="line">        String s2 = <span class="keyword">new</span> String(<span class="string">&quot;def&quot;</span>);</span><br><span class="line">        c.add(s2);</span><br><span class="line"></span><br><span class="line">        String s3 = <span class="keyword">new</span> String(<span class="string">&quot;abc&quot;</span>);</span><br><span class="line">        <span class="comment">//这里返回true为什么？？</span></span><br><span class="line">        <span class="comment">//因为底层代码调用了equals方法比较，而这个内容又是String的，string时重写了equals方法的，所以比较这里比较的时内容，而不是引用。</span></span><br><span class="line">        System.out.println(c.contains(s3));</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    <span class="comment">//源码分析</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">boolean</span> <span class="title">contains</span><span class="params">(Object o)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> indexOf(o) &gt;= <span class="number">0</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">int</span> <span class="title">indexOf</span><span class="params">(Object o)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">if</span> (o == <span class="keyword">null</span>) &#123;</span><br><span class="line">            <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; size; i++)</span><br><span class="line">                <span class="keyword">if</span> (elementData[i]==<span class="keyword">null</span>)</span><br><span class="line">                    <span class="keyword">return</span> i;</span><br><span class="line">        &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">            <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; size; i++)</span><br><span class="line">                <span class="keyword">if</span> (o.equals(elementData[i]))<span class="comment">//这里调用equals进行比较</span></span><br><span class="line">                    <span class="keyword">return</span> i;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> -<span class="number">1</span>;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>内存分析图：<br><img src= "/img/loading.gif" data-lazy-src="https://cdn.jsdelivr.net/gh/my-zhb/CDN/img/20201216210311.png" alt="image"></p><h2 id="Collection的方法：boolean-remove-Object-o"><a href="#Collection的方法：boolean-remove-Object-o" class="headerlink" title="Collection的方法：boolean remove(Object o)"></a>Collection的方法：boolean remove(Object o)</h2><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">CollectionTest4</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line">        Collection c = <span class="keyword">new</span> ArrayList();</span><br><span class="line">        String s1 = <span class="keyword">new</span> String(<span class="string">&quot;hello&quot;</span>);</span><br><span class="line">        c.add(s1);</span><br><span class="line">        String s2 = <span class="keyword">new</span> String(<span class="string">&quot;hello&quot;</span>);</span><br><span class="line">        c.remove(s2);</span><br><span class="line">        <span class="comment">//输出结果0,因为remove方法的底层也调用了equals去比较，String类型底层代码重写了equals方法，比较值</span></span><br><span class="line">        System.out.println(c.size());</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    <span class="comment">//源码</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">boolean</span> <span class="title">remove</span><span class="params">(Object o)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">if</span> (o == <span class="keyword">null</span>) &#123;</span><br><span class="line">            <span class="keyword">for</span> (<span class="keyword">int</span> index = <span class="number">0</span>; index &lt; size; index++)</span><br><span class="line">                <span class="keyword">if</span> (elementData[index] == <span class="keyword">null</span>) &#123;</span><br><span class="line">                    fastRemove(index);</span><br><span class="line">                    <span class="keyword">return</span> <span class="keyword">true</span>;</span><br><span class="line">                &#125;</span><br><span class="line">        &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">            <span class="keyword">for</span> (<span class="keyword">int</span> index = <span class="number">0</span>; index &lt; size; index++)</span><br><span class="line">                <span class="keyword">if</span> (o.equals(elementData[index])) &#123; <span class="comment">//测出调用了equals方法</span></span><br><span class="line">                    fastRemove(index);</span><br><span class="line">                    <span class="keyword">return</span> <span class="keyword">true</span>;</span><br><span class="line">                &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">false</span>;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><blockquote><p>  如果类重写了equals方法：<br>       contains就包含<br>       equals就可以删除<br>   如果不重写equals方法，它会默认取调用Object的equals方法，默认==比较，比较引用<br>       contains就不包含<br>       equals就不可删除  </p></blockquote><h1 id="数据结构"><a href="#数据结构" class="headerlink" title="数据结构"></a>数据结构</h1><h2 id="单向链表结构"><a href="#单向链表结构" class="headerlink" title="单向链表结构"></a>单向链表结构</h2><p><img src= "/img/loading.gif" data-lazy-src="https://cdn.jsdelivr.net/gh/my-zhb/CDN/img/20201216210340.png" alt="image"></p><h2 id="哈希表-散列表结构-Map"><a href="#哈希表-散列表结构-Map" class="headerlink" title="哈希表/散列表结构 Map"></a>哈希表/散列表结构 Map</h2><p><img src= "/img/loading.gif" data-lazy-src="https://cdn.jsdelivr.net/gh/my-zhb/CDN/img/20201216210409.png" alt="image"></p><h2 id="自平衡二叉树-TreeMap就是"><a href="#自平衡二叉树-TreeMap就是" class="headerlink" title="自平衡二叉树 TreeMap就是"></a>自平衡二叉树 TreeMap就是</h2><p><img src= "/img/loading.gif" data-lazy-src="https://cdn.jsdelivr.net/gh/my-zhb/CDN/img/20201216210429.png" alt="image"></p><h1 id="问题"><a href="#问题" class="headerlink" title="问题"></a><code>问题</code></h1><blockquote><p>1.HashMap集合key部分允许为null吗？  </p></blockquote><p>允许，但是HashMap集合的key，null值只能有一个。<br>HashMap集合的key和value都允许为null;</p><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Test</span></span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span></span>&#123;</span><br><span class="line">        Map map = <span class="keyword">new</span> HashMap();</span><br><span class="line">        map.put(<span class="keyword">null</span>,<span class="keyword">null</span>);</span><br><span class="line">        <span class="comment">//这里输出1,说明HashMap的key部分可以为null</span></span><br><span class="line">        System.out.println(map.size());</span><br><span class="line">        map.put(<span class="keyword">null</span>,<span class="number">100</span>);</span><br><span class="line">        <span class="comment">//也可以通过null来进行查询,结果为100</span></span><br><span class="line">        System.out.println(map.get(<span class="keyword">null</span>));</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><blockquote><p>2.HashTable的key可以为null吗？  </p></blockquote><p>HashTable的key河value都不能为空。</p><blockquote><p>3.HashMap和HashTable的区别？  </p></blockquote><ol><li>HashMap线程不安全,HashTable线程安全</li><li>HashMap的key和value都可以为null,HashTable的key和value不允许为null.</li></ol>]]></content>
    
    
    <summary type="html">集合</summary>
    
    
    
    <category term="Java" scheme="https://my-zhb.github.io/categories/Java/"/>
    
    <category term="se" scheme="https://my-zhb.github.io/categories/Java/se/"/>
    
    
    <category term="集合" scheme="https://my-zhb.github.io/tags/%E9%9B%86%E5%90%88/"/>
    
  </entry>
  
  <entry>
    <title>包装类</title>
    <link href="https://my-zhb.github.io/2020/12/14/52c58cb2.html"/>
    <id>https://my-zhb.github.io/2020/12/14/52c58cb2.html</id>
    <published>2020-12-14T12:24:34.000Z</published>
    <updated>2020-12-14T12:34:49.808Z</updated>
    
    <content type="html"><![CDATA[<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">Java中为8种基本数据类型准备了8种包装类型。8种包装类型都属于引用类型。</span><br><span class="line">思考：为什么需要再提供8种包装类型呢？</span><br><span class="line">    因为8种基本数据类型不够用，所以SUN又提供了8种包装类型。</span><br></pre></td></tr></table></figure><h1 id="Java中对每种基本类型都有一个对应的包装类"><a href="#Java中对每种基本类型都有一个对应的包装类" class="headerlink" title="Java中对每种基本类型都有一个对应的包装类"></a>Java中对每种基本类型都有一个对应的包装类</h1><ul><li>byte -&gt; Byte 继承number</li><li>short -&gt; Short 继承number</li><li>int -&gt; Integer 继承number</li><li>long -&gt; Long 继承number</li><li>float -&gt; Float 继承number</li><li>double -&gt; Double 继承number</li><li>boolean -&gt; Boolean 继承Object</li><li>char -&gt; Character  继承Object</li></ul><h1 id="什么是包装类？"><a href="#什么是包装类？" class="headerlink" title="什么是包装类？"></a>什么是包装类？</h1><p>Java种的基本数据类型并不制裁面向对象编程，不具备“对象”的特征，不携带属性、没有方法可以调用，无法提供向上转型取到Object提供的方法。个人理解：就是把基本数据类型封装成对象，有属性，有方法，更能利于开发。</p><h1 id="基本数据类型和包装类的区别？"><a href="#基本数据类型和包装类的区别？" class="headerlink" title="基本数据类型和包装类的区别？"></a>基本数据类型和包装类的区别？</h1><ol><li>定义不同。包装类属于对象，基本数据类型不是。</li><li>声明和使用方式不同，包装类使用new初始化，有些集合类的定义不能使用基本数据类型，例如 ArrayList<Integer></li><li>初始值不同。包装类默认值为null，基本数据类型则不同的类型值不一样</li><li>存储方式和位置不同，从而性能不同。基本数据类型存储在栈(stack)中，包装类则分成引用和实列，引用在栈(stack)中，具体实例在推(heap)中。</li></ol><h1 id="什么是装箱与拆箱？"><a href="#什么是装箱与拆箱？" class="headerlink" title="什么是装箱与拆箱？"></a>什么是装箱与拆箱？</h1><p>将基本数据类型变为包装器类，便是装箱，将包装器类转为基本数据类型就是拆箱</p><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"> <span class="comment">//手动装箱</span></span><br><span class="line">Integer i = <span class="keyword">new</span> Integer(<span class="number">123</span>);</span><br><span class="line"><span class="comment">// 拆箱（floatValue是number的方法，number是基本数据类型的父类除了boolean和char，基本数据类型都有）</span></span><br><span class="line"><span class="keyword">float</span> f = i.floatValue();<span class="comment">//手动拆箱</span></span><br><span class="line"><span class="comment">//输出结果：123.0</span></span><br><span class="line">System.out.println(f);</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="comment">//JDK1.5之后支持自动装箱、自动拆箱</span></span><br><span class="line"><span class="comment">//自动装箱</span></span><br><span class="line">Integer a = <span class="number">100</span>;</span><br><span class="line"><span class="comment">//自动拆箱</span></span><br><span class="line"><span class="keyword">int</span> b = a;</span><br><span class="line"></span><br><span class="line">Integer c = <span class="number">200</span>;</span><br><span class="line">Integer d = <span class="number">100</span>;</span><br><span class="line"><span class="comment">//结果返回：false (==不会触发自动拆箱)</span></span><br><span class="line">System.out.println(c == d);</span><br><span class="line"><span class="comment">//结果返回：true</span></span><br><span class="line">System.out.println(c.equals(d));</span><br></pre></td></tr></table></figure><h1 id="什么时候用包装类？"><a href="#什么时候用包装类？" class="headerlink" title="什么时候用包装类？"></a>什么时候用包装类？</h1><p>看基本的业务来定：这个字段允不允许null值，如果允许null值，则必然要用封装类，否则值类型就可以了，用到比如泛型和反射调用函数.，就需要用包装类！</p><h1 id="常见问题"><a href="#常见问题" class="headerlink" title="常见问题"></a>常见问题</h1><p>理解：  </p><ol><li><p><code>Integer派别：Integer、Short、Byte、Character、Long这几个类的valueOf方法的实现是类似的,它们的默认最大值是128，最小值-128,如果超过就会重新实例化对象，如果超过值用等于等于比较就为false，没超过就为true。</code></p></li><li><p><code>Double派别：Double、Float的valueOf方法的实现是类似的。每次都返回不同的对象。</code>    </p></li><li><p><code>当一个基础数据类型与封装类进行等于等于、+、-、*、/运算时，会将封装类进行拆箱，对基础数据类型进行运算</code></p></li><li><p><code>equals比较是是本身</code></p> <figure class="highlight java"><table><tr><td class="code"><pre><span class="line">Integer i = <span class="number">200</span>;</span><br><span class="line"><span class="keyword">int</span> i1 = <span class="number">200</span>;</span><br><span class="line">System.out.println(i==i1);  <span class="comment">//true</span></span><br><span class="line">System.out.println(i.equals(i1));  <span class="comment">//true</span></span><br><span class="line"></span><br><span class="line">重点：</span><br><span class="line"><span class="number">1.</span> 基本数据类型和包装类比较</span><br><span class="line">    <span class="number">1.1</span> 使用 == ，Java会自动把包装类拆箱，进行值比较，</span><br><span class="line">    <span class="number">1.2</span> 使用equals进行比较也会自动拆箱，然后比较值</span><br><span class="line"><span class="number">2.</span> 包装类型和包装类型比较</span><br><span class="line">    <span class="number">2.1</span> 使用 == 比较，这里如果包装类的值没有超出于取值范围 并且值是一样为<span class="keyword">true</span>，如果超出取值范围就是<span class="keyword">false</span>（这时候与值无关）；</span><br><span class="line">    <span class="number">2.2</span> 使用equals比较,会自动拆箱,然后比较值。值相同为<span class="keyword">true</span>，不同为<span class="keyword">false</span></span><br><span class="line"></span><br><span class="line">Integer i5 = <span class="number">100</span>;</span><br><span class="line">Integer i6 = <span class="number">100</span>;</span><br><span class="line">Long i7 = <span class="number">100L</span>;</span><br><span class="line"><span class="keyword">long</span> i8 = <span class="number">100</span>;</span><br><span class="line"><span class="comment">//编译报错 不同类型的包装类不能使用==比较</span></span><br><span class="line"><span class="comment">//System.out.println(i7==i6); </span></span><br><span class="line"><span class="comment">//不同类型使用equals进行比较 返回false</span></span><br><span class="line">System.out.println(i6.equals(i8)); </span><br><span class="line"><span class="comment">//不同的包装类和基本数据类型使用==比较，只要不超过取值范围为true</span></span><br><span class="line">System.out.println(i6==i8); </span><br></pre></td></tr></table></figure></li></ol><h2 id="取值范围"><a href="#取值范围" class="headerlink" title="取值范围"></a>取值范围</h2><table><thead><tr><th>类型</th><th>相同对象范围</th><th>不同对象范围</th></tr></thead><tbody><tr><td>Integer</td><td>-128,127</td><td>i &gt; 127,i &lt; -128</td></tr><tr><td>Short</td><td>-128,127</td><td>i &gt; 127,i &lt; -128</td></tr><tr><td>Character</td><td>0,127</td><td>i &gt; 128</td></tr><tr><td>Long</td><td>-128,127</td><td>i &gt; 127,i &lt; -128</td></tr></tbody></table><h2 id="Integer"><a href="#Integer" class="headerlink" title="Integer"></a>Integer</h2><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span></span><br><span class="line"><span class="function">    Integer i1 </span>= <span class="number">100</span>;</span><br><span class="line">    Integer i2 = <span class="number">100</span>;</span><br><span class="line">    Integer i3 = <span class="number">200</span>;</span><br><span class="line">    Integer i4 = <span class="number">200</span>;</span><br><span class="line">    <span class="comment">//从源码上来看Integer默认的最大值是127，最小值为-128都是final修饰的不可变，所以这里的i1==i2是true</span></span><br><span class="line">    System.out.println(i1==i2);  <span class="comment">//true</span></span><br><span class="line">        </span><br><span class="line">    <span class="comment">//如果Integer的值最小超过-128或者最大值超过128，它就会重新创建对象，而i3和i4存的引用就是堆里面的引用所以这里返回false</span></span><br><span class="line">    System.out.println(i3==i4);  <span class="comment">//false</span></span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">//下面为源码</span></span><br><span class="line"><span class="keyword">private</span> <span class="keyword">static</span> <span class="class"><span class="keyword">class</span> <span class="title">IntegerCache</span> </span>&#123;</span><br><span class="line">    <span class="keyword">static</span> <span class="keyword">final</span> <span class="keyword">int</span> low = -<span class="number">128</span>;</span><br><span class="line">    <span class="keyword">static</span> <span class="keyword">final</span> <span class="keyword">int</span> high;</span><br><span class="line">    <span class="keyword">static</span> <span class="keyword">final</span> Integer cache[];</span><br><span class="line"></span><br><span class="line">    <span class="keyword">static</span> &#123;</span><br><span class="line">        <span class="comment">// high value may be configured by property</span></span><br><span class="line">        <span class="keyword">int</span> h = <span class="number">127</span>;</span><br><span class="line">        String integerCacheHighPropValue =</span><br><span class="line">            sun.misc.VM.getSavedProperty(<span class="string">&quot;java.lang.Integer.IntegerCache.high&quot;</span>);</span><br><span class="line">        <span class="keyword">if</span> (integerCacheHighPropValue != <span class="keyword">null</span>) &#123;</span><br><span class="line">            <span class="keyword">int</span> i = parseInt(integerCacheHighPropValue);</span><br><span class="line">            i = Math.max(i, <span class="number">127</span>);</span><br><span class="line">            <span class="comment">// Maximum array size is Integer.MAX_VALUE</span></span><br><span class="line">            h = Math.min(i, Integer.MAX_VALUE - (-low) -<span class="number">1</span>);</span><br><span class="line">        &#125;</span><br><span class="line">        high = h;</span><br><span class="line"></span><br><span class="line">        cache = <span class="keyword">new</span> Integer[(high - low) + <span class="number">1</span>];</span><br><span class="line">        <span class="keyword">int</span> j = low;</span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> k = <span class="number">0</span>; k &lt; cache.length; k++)</span><br><span class="line">            cache[k] = <span class="keyword">new</span> Integer(j++);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="function"><span class="keyword">private</span> <span class="title">IntegerCache</span><span class="params">()</span> </span>&#123;&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="Double"><a href="#Double" class="headerlink" title="Double"></a>Double</h2><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line">    Double i1 = <span class="number">100.0</span>;</span><br><span class="line">    Double i2 = <span class="number">100.0</span>;</span><br><span class="line">    Double i3 = <span class="number">200.0</span>;</span><br><span class="line">    Double i4 = <span class="number">200.0</span>;</span><br><span class="line">    </span><br><span class="line">    <span class="comment">//因为Double每次都会去new对象所以这里返回都是false</span></span><br><span class="line">    System.out.println(i1==i2); <span class="comment">//false</span></span><br><span class="line">    System.out.println(i3==i4); <span class="comment">//false</span></span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">//下面为源码</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">static</span> Double <span class="title">valueOf</span><span class="params">(<span class="keyword">double</span> d)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">return</span> <span class="keyword">new</span> Double(d);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="Boolean"><a href="#Boolean" class="headerlink" title="Boolean"></a>Boolean</h2><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line">    Boolean i1 = <span class="keyword">false</span>;</span><br><span class="line">    Boolean i2 = <span class="keyword">false</span>;</span><br><span class="line">    Boolean i3 = <span class="keyword">true</span>;</span><br><span class="line">    Boolean i4 = <span class="keyword">true</span>;</span><br><span class="line">    <span class="comment">//源码可见true和false是static final的</span></span><br><span class="line">    System.out.println(i1==i2);<span class="comment">//true</span></span><br><span class="line">    System.out.println(i3==i4);<span class="comment">//true</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">//下面为源码</span></span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * The &#123;<span class="doctag">@code</span> Boolean&#125; object corresponding to the primitive</span></span><br><span class="line"><span class="comment"> * value &#123;<span class="doctag">@code</span> true&#125;.</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"> </span><br><span class="line"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">final</span> Boolean TRUE = <span class="keyword">new</span> Boolean(<span class="keyword">true</span>);</span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * The &#123;<span class="doctag">@code</span> Boolean&#125; object corresponding to the primitive</span></span><br><span class="line"><span class="comment"> * value &#123;<span class="doctag">@code</span> false&#125;.</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">final</span> Boolean FALSE = <span class="keyword">new</span> Boolean(<span class="keyword">false</span>);</span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">static</span> Boolean <span class="title">valueOf</span><span class="params">(<span class="keyword">boolean</span> b)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">return</span> (b ? TRUE : FALSE);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h1 id="比较"><a href="#比较" class="headerlink" title="比较"></a>比较</h1><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">    Integer num1 = <span class="number">400</span>;</span><br><span class="line">    <span class="keyword">int</span> num2 = <span class="number">400</span>;</span><br><span class="line">    <span class="comment">//这里== 进行了自动拆箱 所以为true        </span></span><br><span class="line">    System.out.println(num1 == num2); <span class="comment">//true</span></span><br><span class="line">    <span class="comment">//我们知道equal比较的是内容本身，并且我们也可以看到equal的参数是一个Object对象，我们传入的是一个int类型，所以首先会进行装箱，然后比较，之所以返回true，是由于它比较的是对象里面的value值。</span></span><br><span class="line">    System.out.println(num1.equals(num2));  <span class="comment">//true</span></span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">//下面为源码</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">boolean</span> <span class="title">equals</span><span class="params">(Object obj)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">if</span> (obj <span class="keyword">instanceof</span> Integer) &#123;</span><br><span class="line">        <span class="keyword">return</span> value == ((Integer)obj).intValue();</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> <span class="keyword">false</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>]]></content>
    
    
    <summary type="html">包装类</summary>
    
    
    
    <category term="Java" scheme="https://my-zhb.github.io/categories/Java/"/>
    
    <category term="se" scheme="https://my-zhb.github.io/categories/Java/se/"/>
    
    
    <category term="Java基础" scheme="https://my-zhb.github.io/tags/Java%E5%9F%BA%E7%A1%80/"/>
    
  </entry>
  
  <entry>
    <title>类型与类型之间的关系</title>
    <link href="https://my-zhb.github.io/2020/12/14/7acf6980.html"/>
    <id>https://my-zhb.github.io/2020/12/14/7acf6980.html</id>
    <published>2020-12-14T12:24:21.000Z</published>
    <updated>2020-12-14T12:33:28.110Z</updated>
    
    <content type="html"><![CDATA[<h1 id="is-a"><a href="#is-a" class="headerlink" title="is a"></a>is a</h1><p>cat is a Animal  （猫是一只动物）<br>凡是能够满足is a的表示“继承关系”<br>A extends B  </p><h1 id="has-a"><a href="#has-a" class="headerlink" title="has a"></a>has a</h1><p>I has a Pen （我有一支笔）<br>凡是能够满足has a 关系的表示“关联关系”<br>关联关系通过以“属性”的形式存在。<br>A{<br>    B b;<br>}</p><h1 id="like-a"><a href="#like-a" class="headerlink" title="like a"></a>like a</h1><p>Cooker like a FoodMenu（厨司像一个菜单一样）<br>凡是能够满足like a 关系的表示“实现关系”<br>实现关系通常是：类实现接口。<br>A implement B  </p>]]></content>
    
    
    <summary type="html">类型与类型之间的关系</summary>
    
    
    
    <category term="Java" scheme="https://my-zhb.github.io/categories/Java/"/>
    
    <category term="se" scheme="https://my-zhb.github.io/categories/Java/se/"/>
    
    
    <category term="Java基础" scheme="https://my-zhb.github.io/tags/Java%E5%9F%BA%E7%A1%80/"/>
    
  </entry>
  
  <entry>
    <title>Java访问控制权限</title>
    <link href="https://my-zhb.github.io/2020/12/14/df717f7d.html"/>
    <id>https://my-zhb.github.io/2020/12/14/df717f7d.html</id>
    <published>2020-12-14T12:24:21.000Z</published>
    <updated>2020-12-14T12:34:55.789Z</updated>
    
    <content type="html"><![CDATA[<table><thead><tr><th>修饰符</th><th>类的内部</th><th>同一包</th><th>子类</th><th>任何地方</th></tr></thead><tbody><tr><td>private</td><td>yes</td><td>no</td><td>no</td><td>no</td></tr><tr><td>default</td><td>yes</td><td>yes</td><td>no</td><td>no</td></tr><tr><td>protected</td><td>yes</td><td>yes</td><td>yes</td><td>no</td></tr><tr><td>public</td><td>yes</td><td>yes</td><td>yes</td><td>yes</td></tr></tbody></table><p>访问控制权限修饰符可以修饰什么？</p><ul><li>属性（4个都能用）</li><li>方法（4个都能用）</li><li>类（public和默认能用，其他不行）</li><li>接口（public和默认能用，其他不行）</li></ul>]]></content>
    
    
    <summary type="html">Java访问控制权限</summary>
    
    
    
    <category term="Java" scheme="https://my-zhb.github.io/categories/Java/"/>
    
    <category term="se" scheme="https://my-zhb.github.io/categories/Java/se/"/>
    
    
    <category term="Java基础" scheme="https://my-zhb.github.io/tags/Java%E5%9F%BA%E7%A1%80/"/>
    
  </entry>
  
  <entry>
    <title>String、StringBuffer、StringBuilder区别</title>
    <link href="https://my-zhb.github.io/2020/12/13/88b1c03b.html"/>
    <id>https://my-zhb.github.io/2020/12/13/88b1c03b.html</id>
    <published>2020-12-13T11:33:11.000Z</published>
    <updated>2020-12-13T11:36:25.868Z</updated>
    
    <content type="html"><![CDATA[<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">思考：</span><br><span class="line">我们在实际的开发中，如果需要进行字符串的频繁拼接，会有什么问题？  </span><br><span class="line">因为java中的字符串是不可变的，每一次拼接都会产生新字符串。</span><br><span class="line">这样会占用大量的方法区内存，造成内存空间浪费。</span><br><span class="line">例如：</span><br><span class="line">    String s &#x3D; &quot;abc&quot;;</span><br><span class="line">    s +&#x3D; &quot;hello&quot;;</span><br><span class="line">    就以上两行代码，就导致在方法区字符串常量池当中创建了3个对象：</span><br><span class="line">    “abc”  &quot;hello&quot; &quot;abchello&quot;</span><br><span class="line"></span><br><span class="line">所以在大量的字符串拼接中，我们可以采用JDK自带的：</span><br><span class="line">    java.long.StringBuffer</span><br><span class="line">    java.long.StringBuilder</span><br></pre></td></tr></table></figure><h1 id="String、StringBuffer、StringBuilder"><a href="#String、StringBuffer、StringBuilder" class="headerlink" title="String、StringBuffer、StringBuilder"></a>String、StringBuffer、StringBuilder</h1><ol><li>StringBuffer、StringBuilder底层实际上是一个byte[]数组，往StringBuffer、StringBuilder中放字符串，实际上是放在byte数组当中的</li><li>StringBuffer、StringBuilder的初始容量是16。</li><li>StringBuffer、StringBuilder调用append()方法进行追加，如果容量不够，会自动扩容。底层实现原理通过System.arraycopy()方法进行扩容处理。</li><li>String的底层也是byte[]数组只不过是final修饰过的，所以不能改变。</li><li>如何优化StringBuffer、StringBuilder的性能？<br> <code>在创建StringBuffer、StringBuilder的时候尽可能的给定一个合适的初始容量，最好减少底层数组的扩容次数。</code></li></ol><h1 id="问题"><a href="#问题" class="headerlink" title="问题"></a>问题</h1><ol><li>String、StringBuffer、StringBuilder的区别？<ul><li>  StringBuffer中所有方法都有：synchronized关键字修饰，表示线程安全，在多线程下是安全的，但是效率较低，长度可变。</li><li>  StringBuilder没有synchronized关键字修饰，表示不线程安全，在多线程下是不安全的,但是效率高，长度可变。</li><li>  String是不可变的，因为String的底层也是byte[]数组只不过是final修饰过的，所以不能改变。</li></ul></li></ol>]]></content>
    
    
    <summary type="html">String、StringBuffer、StringBuilder区别</summary>
    
    
    
    <category term="Java" scheme="https://my-zhb.github.io/categories/Java/"/>
    
    <category term="se" scheme="https://my-zhb.github.io/categories/Java/se/"/>
    
    
    <category term="Java基础" scheme="https://my-zhb.github.io/tags/Java%E5%9F%BA%E7%A1%80/"/>
    
  </entry>
  
  <entry>
    <title>String类</title>
    <link href="https://my-zhb.github.io/2020/12/12/5cf35ca9.html"/>
    <id>https://my-zhb.github.io/2020/12/12/5cf35ca9.html</id>
    <published>2020-12-12T13:17:01.000Z</published>
    <updated>2020-12-12T13:48:40.848Z</updated>
    
    <content type="html"><![CDATA[<h1 id="String是上面"><a href="#String是上面" class="headerlink" title="String是上面"></a>String是上面</h1><ol><li>String表示字符串类型，属于引用数据类型，不属于基本数据类型。</li><li>Java中规定，双引号括起来的字符串，是不可变的，也就是说“abc”自出生到最终死亡，都是不能改变的。</li><li>在JDK当中双引号括起来的字符串，例如：“abc” 都是直接存储在方法区的字符串常量池当中的。</li></ol><p>内存分析：</p><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Test</span></span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span></span>&#123;</span><br><span class="line">        <span class="comment">//s1 和s2 一共创建了3个字符串对象，都在字符串常量池当做</span></span><br><span class="line">        String s1 = <span class="string">&quot;abcdef&quot;</span>;</span><br><span class="line">        String s2 = <span class="string">&quot;abcdef&quot;</span>+<span class="string">&quot;xy&quot;</span>;</span><br><span class="line">        <span class="comment">//凡是使用双引号括起来的都在字符串常量池中有一份.</span></span><br><span class="line">        <span class="comment">//new对象的时候一定在堆内存当中开辟空间</span></span><br><span class="line">        <span class="comment">//所以 栈当中s3存的是 推内存的地址 ，而堆内存当做存的是xy在字符串常量池中的地址</span></span><br><span class="line">        String s3 = <span class="keyword">new</span> String(<span class="string">&quot;xy&quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>内存图：<br><img src= "/img/loading.gif" data-lazy-src="https://img-blog.csdnimg.cn/20200917140308302.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3FxXzM2NTE0NzY2,size_16,color_FFFFFF,t_70" alt="image"></p><h1 id="常用的方法"><a href="#常用的方法" class="headerlink" title="常用的方法"></a>常用的方法</h1><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Test</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line">        <span class="comment">/**(掌握)1. charAt(index) **/</span></span><br><span class="line">        <span class="keyword">char</span> c = <span class="string">&quot;中国人&quot;</span>.charAt(<span class="number">1</span>);</span><br><span class="line">        <span class="comment">//输出国</span></span><br><span class="line">        System.out.println(c);</span><br><span class="line"></span><br><span class="line">        <span class="comment">/**(掌握)2. int compareTo(String anotherString)</span></span><br><span class="line"><span class="comment">         * 按照字典顺序比较两个字符串</span></span><br><span class="line"><span class="comment">         * **/</span></span><br><span class="line">        <span class="keyword">int</span> result = <span class="string">&quot;a&quot;</span>.compareTo(<span class="string">&quot;a&quot;</span>);</span><br><span class="line">        <span class="comment">//输出0 前后一致 举例：10 - 10 = 0</span></span><br><span class="line">        System.out.println(result);</span><br><span class="line">        <span class="keyword">int</span> result2 = <span class="string">&quot;d&quot;</span>.compareTo(<span class="string">&quot;e&quot;</span>);</span><br><span class="line">        <span class="comment">//输出-1 前小后大 举例：10 - 11 = -1</span></span><br><span class="line">        System.out.println(result2);</span><br><span class="line">        <span class="keyword">int</span> result3 = <span class="string">&quot;e&quot;</span>.compareTo(<span class="string">&quot;d&quot;</span>);</span><br><span class="line">        <span class="comment">//输出0 前大后小  举例：11 - 10 = 1</span></span><br><span class="line">        System.out.println(result3);</span><br><span class="line"></span><br><span class="line">        <span class="comment">/**(掌握)3. boolean contains(CharSequence s)</span></span><br><span class="line"><span class="comment">         * 当且仅当此字符串包含指定的char值序列是，返回true</span></span><br><span class="line"><span class="comment">         * **/</span></span><br><span class="line">        <span class="comment">//如果包含就为true</span></span><br><span class="line">        System.out.println(<span class="string">&quot;abc&quot;</span>.contains(<span class="string">&quot;a&quot;</span>));</span><br><span class="line">        <span class="comment">//不包含为false</span></span><br><span class="line">        System.out.println(<span class="string">&quot;abc&quot;</span>.contains(<span class="string">&quot;d&quot;</span>));</span><br><span class="line"></span><br><span class="line">        <span class="comment">/**(掌握)4. boolean endsWith(Sting suffix)</span></span><br><span class="line"><span class="comment">         * 判断当前字符串是否以某个字符串结尾。</span></span><br><span class="line"><span class="comment">         * **/</span></span><br><span class="line">        <span class="comment">//返回false 结尾不是以.java结尾的</span></span><br><span class="line">        System.out.println(<span class="string">&quot;test.txt&quot;</span>.endsWith(<span class="string">&quot;.java&quot;</span>));</span><br><span class="line">        <span class="comment">//返回true</span></span><br><span class="line">        System.out.println(<span class="string">&quot;test.txt&quot;</span>.endsWith(<span class="string">&quot;.txt&quot;</span>));</span><br><span class="line"></span><br><span class="line">        <span class="comment">/**(掌握)5. boolean startWith(Sting suffix)</span></span><br><span class="line"><span class="comment">         * 判断当前字符串是否以某个字符串开始</span></span><br><span class="line"><span class="comment">         * **/</span></span><br><span class="line">        <span class="comment">//返回true 因为这个字符串就是以test开始的</span></span><br><span class="line">        System.out.println(<span class="string">&quot;test.txt&quot;</span>.endsWith(<span class="string">&quot;test&quot;</span>));</span><br><span class="line">        <span class="comment">//返回false 因为字符串不是以a开始的</span></span><br><span class="line">        System.out.println(<span class="string">&quot;test.txt&quot;</span>.endsWith(<span class="string">&quot;a&quot;</span>));</span><br><span class="line"></span><br><span class="line">        <span class="comment">/**(掌握)6. boolean equals(Object anObject)</span></span><br><span class="line"><span class="comment">         * 比较两个字符串必须使用equals方法，不能使用“==”</span></span><br><span class="line"><span class="comment">         * **/</span></span><br><span class="line">        <span class="comment">//返回true</span></span><br><span class="line">        System.out.println(<span class="string">&quot;abc&quot;</span>.equals(<span class="string">&quot;abc&quot;</span>));</span><br><span class="line">        <span class="comment">//返回false</span></span><br><span class="line">        System.out.println(<span class="string">&quot;abc&quot;</span>.equals(<span class="string">&quot;abcd&quot;</span>));</span><br><span class="line"></span><br><span class="line">        <span class="comment">/**(掌握)7. boolean equalsIgnoreCase(String antherString)</span></span><br><span class="line"><span class="comment">         * 判断两个字符串是否相等，并且忽略大小写</span></span><br><span class="line"><span class="comment">         * **/</span></span><br><span class="line">        <span class="comment">//返回true 因为忽略了大小写</span></span><br><span class="line">        System.out.println(<span class="string">&quot;abc&quot;</span>.equalsIgnoreCase(<span class="string">&quot;ABc&quot;</span>));</span><br><span class="line"></span><br><span class="line">        <span class="comment">/**(掌握)8. byte[] getBytes()</span></span><br><span class="line"><span class="comment">         * 将字符串对象转换成字节数组</span></span><br><span class="line"><span class="comment">         * **/</span></span><br><span class="line">        <span class="keyword">byte</span>[] bytes = <span class="string">&quot;abcdef&quot;</span>.getBytes();</span><br><span class="line">        <span class="comment">//输出结果 97 98 99 100 101 102</span></span><br><span class="line">        <span class="comment">//把每个字符串都拆分 并且转换</span></span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt;bytes.length ; i++) &#123;</span><br><span class="line">            System.out.print(bytes[i]+<span class="string">&quot; &quot;</span>);</span><br><span class="line">        &#125;</span><br><span class="line">        System.out.println();</span><br><span class="line"></span><br><span class="line">        <span class="comment">/**(掌握)9. int indexOf(String str)</span></span><br><span class="line"><span class="comment">         * 判断某个字符串在当前字符串第一次出现处的索引</span></span><br><span class="line"><span class="comment">         * **/</span></span><br><span class="line">        <span class="comment">//输出下标1,因为b在这个字符串的下标1，第一次出现</span></span><br><span class="line">        System.out.println(<span class="string">&quot;abcbef&quot;</span>.indexOf(<span class="string">&quot;b&quot;</span>));</span><br><span class="line"></span><br><span class="line">        <span class="comment">/**(掌握)10. int lastIndexOf(String str)</span></span><br><span class="line"><span class="comment">         * 判断某个字符串在当前字符串最后一次次出现处的索引</span></span><br><span class="line"><span class="comment">         * **/</span></span><br><span class="line">        <span class="comment">//输出结果：3 ,因为b在当前字符串最后一次出现的索引是3</span></span><br><span class="line">        System.out.println(<span class="string">&quot;abcbef&quot;</span>.lastIndexOf(<span class="string">&quot;b&quot;</span>));</span><br><span class="line"></span><br><span class="line">        <span class="comment">/**(掌握)11. boolean isEmpty()</span></span><br><span class="line"><span class="comment">         * 判断某个字符串是否为空</span></span><br><span class="line"><span class="comment">         * 这里判断的是空字符串“”，而不是null，如果s=null的话 调用此方法会出现空指针异常</span></span><br><span class="line"><span class="comment">         * 这个方法底层调用的就是string的length方法。</span></span><br><span class="line"><span class="comment">         * **/</span></span><br><span class="line">        String s = <span class="string">&quot;&quot;</span>;</span><br><span class="line">        <span class="comment">//返回true 因为是空字符串</span></span><br><span class="line">        System.out.println(s.isEmpty());</span><br><span class="line"></span><br><span class="line">        <span class="comment">/**(掌握)12. int length()</span></span><br><span class="line"><span class="comment">         * 判断某个字符串的长度</span></span><br><span class="line"><span class="comment">         * 面试题：判断数组长度和判断字符串长度不一样</span></span><br><span class="line"><span class="comment">         * 判断数组长度用的是length属性，判断字符串长度是length()方法</span></span><br><span class="line"><span class="comment">         * **/</span></span><br><span class="line">        <span class="comment">//输出结果：3</span></span><br><span class="line">        System.out.println(<span class="string">&quot;abc&quot;</span>.length());</span><br><span class="line"></span><br><span class="line">        <span class="comment">/**(掌握)13. String replace(CharSequence target,CharSequence replacement)</span></span><br><span class="line"><span class="comment">         * 字符串替换</span></span><br><span class="line"><span class="comment">         * String的父接口就是：CharSequence</span></span><br><span class="line"><span class="comment">         * **/</span></span><br><span class="line">        <span class="comment">//输出结果：https://myiszhb.cn ,把字符串中的http替换成https</span></span><br><span class="line">        System.out.println(<span class="string">&quot;http://myiszhb.cn&quot;</span>.replace(<span class="string">&quot;http&quot;</span>,<span class="string">&quot;https&quot;</span>));</span><br><span class="line"></span><br><span class="line">        <span class="comment">/**(掌握)14. String[] split(String regex)</span></span><br><span class="line"><span class="comment">         *  字符串切割</span></span><br><span class="line"><span class="comment">         * **/</span></span><br><span class="line">        String[] vs = <span class="string">&quot;avcdefg&quot;</span>.split(<span class="string">&quot;c&quot;</span>);</span><br><span class="line">        <span class="comment">//输出结果av defg ，因为是按照c进行分割的</span></span><br><span class="line">        <span class="keyword">for</span> (String v : vs) &#123;</span><br><span class="line">            System.out.print(v+<span class="string">&quot; &quot;</span>);</span><br><span class="line">        &#125;</span><br><span class="line">        System.out.println();</span><br><span class="line"></span><br><span class="line">        <span class="comment">/**(掌握)15. String substring(int beginIndex)</span></span><br><span class="line"><span class="comment">         *  截取字符串</span></span><br><span class="line"><span class="comment">         * **/</span></span><br><span class="line">        <span class="comment">//输出结果：ttps://myiszhb.cn 因为是从索引1还是截取的</span></span><br><span class="line">        System.out.println(<span class="string">&quot;https://myiszhb.cn&quot;</span>.substring(<span class="number">1</span>));</span><br><span class="line"></span><br><span class="line">        <span class="comment">/**(掌握)16. String substring(int beginIndex，int endIndex)</span></span><br><span class="line"><span class="comment">         *  截取字符串 substring的重载方法</span></span><br><span class="line"><span class="comment">         *  参数： beginIndex - 起始索引（包括）</span></span><br><span class="line"><span class="comment">         *         endIndex  -  结束索引（不包括）</span></span><br><span class="line"><span class="comment">         * **/</span></span><br><span class="line">        <span class="comment">//输出结果：tt 因为是从索引1开始截取，到索引3结束</span></span><br><span class="line">        System.out.println(<span class="string">&quot;https://myiszhb.cn&quot;</span>.substring(<span class="number">1</span>,<span class="number">3</span>));</span><br><span class="line"></span><br><span class="line">        <span class="comment">/**(掌握)17. char[] toCharArray()</span></span><br><span class="line"><span class="comment">         *  将字符串转换成char数组</span></span><br><span class="line"><span class="comment">         * **/</span></span><br><span class="line">        <span class="keyword">char</span>[] chars = <span class="string">&quot;我是四川人&quot;</span>.toCharArray();</span><br><span class="line">        <span class="comment">//输出结果： 我 是 四 川 人</span></span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">char</span> aChar : chars) &#123;</span><br><span class="line">            System.out.print(aChar+<span class="string">&quot; &quot;</span>);</span><br><span class="line">        &#125;</span><br><span class="line">        System.out.println();</span><br><span class="line"></span><br><span class="line">        <span class="comment">/**(掌握)18. String toLowerCase()</span></span><br><span class="line"><span class="comment">         *  将字符串转换成小写</span></span><br><span class="line"><span class="comment">         * **/</span></span><br><span class="line">        <span class="comment">//输出结果：abc</span></span><br><span class="line">        System.out.println(<span class="string">&quot;ABC&quot;</span>.toLowerCase());</span><br><span class="line"></span><br><span class="line">        <span class="comment">/**(掌握)19. String toUpperCase()</span></span><br><span class="line"><span class="comment">         *  将字符串转换成大写</span></span><br><span class="line"><span class="comment">         * **/</span></span><br><span class="line">        <span class="comment">//输出结果：ABC</span></span><br><span class="line">        System.out.println(<span class="string">&quot;abc&quot;</span>.toUpperCase());</span><br><span class="line"></span><br><span class="line">        <span class="comment">/**(掌握)20. String trim()</span></span><br><span class="line"><span class="comment">         *  忽略字符串前面和尾部的空白</span></span><br><span class="line"><span class="comment">         * **/</span></span><br><span class="line">        <span class="comment">//输出结果：asf f 前面后面的空白就去除了 中间的不会去除</span></span><br><span class="line">        System.out.println(<span class="string">&quot; asf f &quot;</span>.trim());</span><br><span class="line"></span><br><span class="line">        <span class="comment">/**(掌握)21. valueOf()</span></span><br><span class="line"><span class="comment">         * String中只有一个方法是静态的，不需要new对象 那就是valueOf()方法</span></span><br><span class="line"><span class="comment">         *  将非字符串（不是字符串的）转换成字符串</span></span><br><span class="line"><span class="comment">         * **/</span></span><br><span class="line">        <span class="comment">//输出结果:1 ,而这里输出出来的1已经变成字符串的1了，而不是int类型的1</span></span><br><span class="line">        System.out.println(String.valueOf(<span class="number">1</span>));</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>]]></content>
    
    
    <summary type="html">String</summary>
    
    
    
    <category term="Java" scheme="https://my-zhb.github.io/categories/Java/"/>
    
    <category term="se" scheme="https://my-zhb.github.io/categories/Java/se/"/>
    
    
    <category term="Java基础" scheme="https://my-zhb.github.io/tags/Java%E5%9F%BA%E7%A1%80/"/>
    
  </entry>
  
  <entry>
    <title>多种数据类型混合运算</title>
    <link href="https://my-zhb.github.io/2020/12/11/d57302f2.html"/>
    <id>https://my-zhb.github.io/2020/12/11/d57302f2.html</id>
    <published>2020-12-11T12:18:34.000Z</published>
    <updated>2020-12-11T12:21:58.584Z</updated>
    
    <content type="html"><![CDATA[<h1 id="byte、short、char混合运算"><a href="#byte、short、char混合运算" class="headerlink" title="byte、short、char混合运算"></a>byte、short、char混合运算</h1><p>结论:byte、char、short 做混合运算的时候，各自先转换成int再做运算。</p><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Test</span></span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">mian</span><span class="params">(String[]args)</span></span>&#123;</span><br><span class="line">        <span class="keyword">char</span> c1 = <span class="string">&#x27;a&#x27;</span>;</span><br><span class="line">        <span class="keyword">byte</span> b = <span class="number">1</span>;</span><br><span class="line">        <span class="comment">//这里可以输出98，因为ascll表a的值是97</span></span><br><span class="line">        System.out.println(c1+b);</span><br><span class="line">        </span><br><span class="line">        <span class="comment">//short s = c1+b;这里编译出错，编译器不知道这个结果是什么。</span></span><br><span class="line">        </span><br><span class="line">       <span class="comment">// short d = (short)c1+b;这里也是编译出错，因为它先把c1转换成了short然后在和b相加，最终结果还是不知道。</span></span><br><span class="line">        </span><br><span class="line">        <span class="keyword">short</span> f = (<span class="keyword">short</span>)(c1+b);<span class="comment">//这里可以正常编译，因为它是把c1+b进行相加后 在强转成short的</span></span><br><span class="line">        </span><br><span class="line">        <span class="keyword">int</span> s = <span class="number">1</span>;</span><br><span class="line">        <span class="comment">//short d = s;这里编译出错，因为s的值要运行时才知道，而这里还没运行 编译器不知道，直接出错。</span></span><br><span class="line">        <span class="keyword">short</span> d = <span class="number">1</span>;<span class="comment">//这里正常，因为编译器知道这个值。</span></span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h1 id="多种数据类型混合运算-整数型"><a href="#多种数据类型混合运算-整数型" class="headerlink" title="多种数据类型混合运算(整数型)"></a>多种数据类型混合运算(整数型)</h1><p>结论：多种数据类型做混合运算的时候，最终结果是最大容量的类型<br>注意：byte、char、short 除外，会各自先转换成int</p><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Test</span></span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">mian</span><span class="params">(String[]args)</span></span>&#123;</span><br><span class="line">        <span class="keyword">long</span> a = <span class="number">10L</span>;</span><br><span class="line">        <span class="keyword">char</span> b = <span class="string">&#x27;a&#x27;</span>;</span><br><span class="line">        <span class="keyword">short</span> s = <span class="number">100</span>;</span><br><span class="line">        <span class="keyword">int</span> i = <span class="number">30</span>;</span><br><span class="line">        <span class="comment">//求和</span></span><br><span class="line">        System.out.println(a+b+s+i);</span><br><span class="line">        <span class="comment">//int d = a+b+s+i;//这里算出来是long类型，编译错误 不兼容类型：从long转换成int</span></span><br><span class="line">        </span><br><span class="line">        <span class="comment">//以下程序执行结果是？</span></span><br><span class="line">        <span class="keyword">int</span> temp = <span class="number">10</span>/<span class="number">3</span>;<span class="comment">//结果为：3，因为int/int类型结果还是int类型，最终结果取整。</span></span><br><span class="line">        <span class="keyword">int</span> temp2 = <span class="number">1</span>/<span class="number">2</span>;<span class="comment">//结果为：0，因为int/int类型结果还是int类型，最终结果取整。</span></span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h1 id="浮点型混合运算-浮点型"><a href="#浮点型混合运算-浮点型" class="headerlink" title="浮点型混合运算(浮点型)"></a>浮点型混合运算(浮点型)</h1><ul><li>浮点型包括<ul><li>  float 4个字节 单精度</li><li>  double 8个字节 双精度</li></ul></li></ul><p>例如：<br>10.0/3 如果采用float来存储的话结果可能是：3.3333<br>10.0/3 如果采用double来存储的话结果可能是：3.33333333<br><code>注意：double不能用于财务方面的运算，会丢失精度，最好使用BigDecimal，BigDecimal属于引用类型</code></p><p>float和double存储数据的时候都是存储的近似值，因为在运算的时候有时候会出现无限循环的数据。</p><p><code>注意：任意一个浮点型数据的类型容量都比整数数据类型容量大。</code>  </p><p><code>注意：java中规定任何一个浮点型都会默认被当做double来处理，如果想让这个浮点数字面量被当做flota类型来处理，那么要在字面量后面加上F/f</code></p><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">float</span> f = <span class="number">3.14</span>;<span class="comment">//编译出错，不兼容的类型，从double转成float</span></span><br><span class="line"><span class="comment">//第一种转换方法：</span></span><br><span class="line"><span class="keyword">float</span> a = <span class="number">3.14F</span>;(或者<span class="number">3.14f</span>)</span><br><span class="line"></span><br><span class="line">/第二种 强制转换，可能会丢失精度，谨慎使用</span><br><span class="line"><span class="keyword">float</span> c = (<span class="keyword">float</span>)<span class="number">3.14</span>;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="comment">//分析这个程序，可以编译吗？</span></span><br><span class="line"><span class="comment">//错误：不兼容的类型，从double转成int</span></span><br><span class="line"><span class="comment">//原理：先将5转换成double类型，然后在做运算，结果是double，大容量无法直接赋值给小容量，需要强转！</span></span><br><span class="line"><span class="keyword">int</span> i = <span class="number">10.0</span>/<span class="number">5</span>;</span><br><span class="line"></span><br></pre></td></tr></table></figure>]]></content>
    
    
    <summary type="html">多种数据类型混合运算</summary>
    
    
    
    <category term="Java" scheme="https://my-zhb.github.io/categories/Java/"/>
    
    <category term="se" scheme="https://my-zhb.github.io/categories/Java/se/"/>
    
    
    <category term="Java基础" scheme="https://my-zhb.github.io/tags/Java%E5%9F%BA%E7%A1%80/"/>
    
  </entry>
  
  <entry>
    <title>二进制的原码、反码、补码</title>
    <link href="https://my-zhb.github.io/2020/12/10/c3d59d66.html"/>
    <id>https://my-zhb.github.io/2020/12/10/c3d59d66.html</id>
    <published>2020-12-10T12:06:58.000Z</published>
    <updated>2020-12-11T12:19:52.074Z</updated>
    
    <content type="html"><![CDATA[<ol><li>计算机在任何情况下都只能识别二进制</li><li>计算机在底层存储数据的时候，一律存储的是”二进制的补码形式”，计算机采用补码形式存储数据的原因是：补码形式效率最高</li><li>什么是补码？<br>二进制有：原码 反码 补码<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="comment">//对于一个正数来说：二进制原码、反码、补码是同一个，完全相同</span></span><br><span class="line"><span class="keyword">int</span> i = <span class="number">1</span>;</span><br><span class="line">对应的二进制原码：<span class="number">00000000</span> <span class="number">00000000</span> <span class="number">00000000</span> <span class="number">00000001</span></span><br><span class="line">对应的二进制反码：<span class="number">00000000</span> <span class="number">00000000</span> <span class="number">00000000</span> <span class="number">00000001</span></span><br><span class="line">对应的二进制补码：<span class="number">00000000</span> <span class="number">00000000</span> <span class="number">00000000</span> <span class="number">00000001</span></span><br><span class="line"></span><br><span class="line"><span class="comment">//对一个负数来说：二进制原码、反码、补码是什么关系呢？</span></span><br><span class="line"><span class="keyword">byte</span> i = -<span class="number">1</span>;</span><br><span class="line">对应的二进制原码： <span class="number">10000001</span></span><br><span class="line">对应的二进制反码(符号位不变，其他位取反)： <span class="number">11111110</span></span><br><span class="line">对应的二进制补码(反码+<span class="number">1</span>)： <span class="number">11111111</span></span><br></pre></td></tr></table></figure>问题：byte b = (byte)150；输出多少？？<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">byte</span> b = (<span class="keyword">byte</span>)<span class="number">150</span>;<span class="comment">//这里输出-106</span></span><br><span class="line"></span><br><span class="line">    <span class="number">128</span> <span class="number">64</span> <span class="number">32</span> <span class="number">16</span> <span class="number">8</span> <span class="number">4</span> <span class="number">2</span> <span class="number">0</span></span><br><span class="line">    <span class="number">1</span>   <span class="number">0</span>  <span class="number">0</span>  <span class="number">0</span>  <span class="number">0</span> <span class="number">0</span> <span class="number">0</span> <span class="number">0</span> （这里是<span class="number">128</span>，<span class="number">150</span>-<span class="number">128</span>=<span class="number">22</span>）</span><br><span class="line">    <span class="number">1</span>   <span class="number">0</span>  <span class="number">0</span>  <span class="number">1</span>  <span class="number">0</span> <span class="number">1</span> <span class="number">1</span> <span class="number">0</span> （<span class="number">16</span>+<span class="number">4</span>+<span class="number">2</span>=<span class="number">22</span>）</span><br><span class="line">    </span><br><span class="line"><span class="number">11001</span> <span class="number">0110</span> (最终结果这是一个二进制补码形式)</span><br><span class="line">二进制原码为：<span class="number">1110</span> <span class="number">1010</span></span><br><span class="line">二进制反码为：<span class="number">1001</span> <span class="number">0101</span></span><br><span class="line">二进制补码为：<span class="number">1001</span> <span class="number">0110</span></span><br><span class="line">其中符号位是<span class="number">1</span>所以是负数</span><br><span class="line"><span class="number">0</span>+<span class="number">2</span>+<span class="number">0</span>+<span class="number">8</span>+<span class="number">0</span>+<span class="number">32</span>+<span class="number">64</span>=-<span class="number">106</span></span><br></pre></td></tr></table></figure></li></ol>]]></content>
    
    
      
      
    <summary type="html">&lt;ol&gt;
&lt;li&gt;计算机在任何情况下都只能识别二进制&lt;/li&gt;
&lt;li&gt;计算机在底层存储数据的时候，一律存储的是”二进制的补码形式”，计算机采用补码形式存储数据的原因是：补码形式效率最高&lt;/li&gt;
&lt;li&gt;什么是补码？&lt;br&gt;二进制有：原码 反码 补码&lt;figure class=</summary>
      
    
    
    
    <category term="Java" scheme="https://my-zhb.github.io/categories/Java/"/>
    
    <category term="se" scheme="https://my-zhb.github.io/categories/Java/se/"/>
    
    
    <category term="Java基础" scheme="https://my-zhb.github.io/tags/Java%E5%9F%BA%E7%A1%80/"/>
    
  </entry>
  
  <entry>
    <title>异常</title>
    <link href="https://my-zhb.github.io/2020/12/09/23a3bd72.html"/>
    <id>https://my-zhb.github.io/2020/12/09/23a3bd72.html</id>
    <published>2020-12-09T11:41:47.000Z</published>
    <updated>2020-12-11T12:20:19.685Z</updated>
    
    <content type="html"><![CDATA[<h1 id="什么是异常"><a href="#什么是异常" class="headerlink" title="什么是异常"></a>什么是异常</h1><ol><li>软件程序运行过程中，非常可能遇到问题，这就是异常。</li><li>异常指程序运行中出现的不期而遇的各种状况，如：文件找不到，网络连接失败等。</li><li>异常发生在程序运行期间，它影响了正常的程序执行流程。</li><li>一次在Java中以类的形式存在，每一个异常类都可以创建异常对象</li></ol><h1 id="异常分为三种类型"><a href="#异常分为三种类型" class="headerlink" title="异常分为三种类型"></a>异常分为三种类型</h1><ol><li>检查性异常<br>最具代表的检查性异常时用户错误或问题引发的异常，这是程序员无法预见的，例如打开了一个不存在的文件时，一个异常就发送了，这些异常在编译时不能被简单地忽略。</li><li>运行时异常<br>运行时异常时可以被程序员避免的异常。与检查性异常相反，运行时异常可以在编译时被忽略。</li><li>错误<br>错误不是异常，而实脱离程序员控制的问题。错误在代码中通常被忽略。例如，当栈溢出时，一个错误就发生了，它们在编译也检查不到的。</li></ol><h1 id="异常体系结构"><a href="#异常体系结构" class="headerlink" title="异常体系结构"></a>异常体系结构</h1><ol><li>Java把异常当作对象来处理，并定义一个基类java.long.Throwable做为所有异常的超类。</li><li>在Java API中已定义了很多异常类，这些异常类分为两大类<ul><li>错误 Error</li><li>异常 Exception</li></ul></li></ol><h1 id="异常处理机制"><a href="#异常处理机制" class="headerlink" title="异常处理机制"></a>异常处理机制</h1><p>处理异常的五个关键字</p><ul><li>try  （try…catch，可以只有try）</li><li>catch   （catch和try连用，没有try是不行的）</li><li>finally （不管什么情况，finally块中的代码都会执行,除非碰到System.exit(0)退出jvm虚拟机）</li><li>throw() （throw()主动抛出异常）</li><li>throws （throws向上级抛出异常，如果抛到jvm虚拟机，程序将直接停止）</li></ul><p>try…cathc语句中出现finally块，不管程序是否出现异常或者return，finally块中的代码都会执行，除非碰到System.exit(0)退出jvm虚拟机。</p><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Test</span></span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] agrs)</span></span>&#123;</span><br><span class="line">        <span class="keyword">try</span>&#123;</span><br><span class="line">              System.out.println(<span class="string">&quot;try&quot;</span>);</span><br><span class="line">              <span class="keyword">return</span>;</span><br><span class="line">        &#125;<span class="keyword">catch</span>(Exception e)&#123;</span><br><span class="line">            System.out.println(<span class="string">&quot;catch&quot;</span>)</span><br><span class="line">        &#125;<span class="keyword">finally</span>&#123;</span><br><span class="line">            System.out.println(<span class="string">&quot;finaly&quot;</span>)</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h1 id="自定义异常"><a href="#自定义异常" class="headerlink" title="自定义异常"></a>自定义异常</h1><ol><li>创建自定义异常类。</li><li>在方法中通过throw关键字抛出异常对象。</li><li>如果在当前抛出异常的方法中处理异常，可以使用try-catch语句捕获并处理；否则在方法的声明处理throws关键字指明要抛出给方法调用者的异常，继续进行下一步操作。</li><li>在出现异常方法的调用者中捕获并处理异常。</li></ol><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="comment">//自定义异常extends Exception</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">MyException</span> <span class="keyword">extends</span> <span class="title">Exception</span></span>&#123;</span><br><span class="line">    <span class="keyword">private</span> String name;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="title">MyException</span><span class="params">(String name)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">this</span>.name = name;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> String <span class="title">toString</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="string">&quot;MyException&#123;&quot;</span>+<span class="keyword">this</span>.name+<span class="string">&quot;自定义了一个异常&#125;,&quot;</span>;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h1 id="异常问题"><a href="#异常问题" class="headerlink" title="异常问题"></a>异常问题</h1><ol><li>个人理解如果方法内，return 返回的对象可以不用赋值的话，在finally里面就可以更改，如果必须赋初始化值，finally里面就无法改变，列入：<br> String s = null; 不可改变<br> List list = null;不可改变<br> List list = new ArryList();可改变 <figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Test</span></span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] ages)</span></span>&#123;</span><br><span class="line">        <span class="keyword">int</span> result = m();</span><br><span class="line">        <span class="comment">//输出100</span></span><br><span class="line">        System.out.println(result);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">//Java语法规则（有一些规则是不能破坏的，一旦这么说，就必须这么做！）</span></span><br><span class="line">    <span class="comment">/**Java中有一条这样的规则：</span></span><br><span class="line"><span class="comment">      * 1.方法体中的代码必须遵循自上而下顺序依次逐行执行！</span></span><br><span class="line"><span class="comment">      * 2.return语句一旦执行，整个方法必须结束！</span></span><br><span class="line"><span class="comment">      **/</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">int</span> <span class="title">m</span><span class="params">()</span></span>&#123;</span><br><span class="line">        <span class="keyword">int</span> i = <span class="number">100</span>;</span><br><span class="line">        <span class="keyword">try</span>&#123;</span><br><span class="line">            <span class="comment">//这行代码出现在int i = 100 的下面，所以最终结果必须是返回100</span></span><br><span class="line">            <span class="comment">//return语句还必须保证是最后执行的，一旦执行，整个方法结束。</span></span><br><span class="line">            <span class="keyword">return</span> i;</span><br><span class="line">        &#125;<span class="keyword">finally</span>&#123;</span><br><span class="line">            i++;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">2. final、finally、finalize的区别？</span><br><span class="line">    1. final是一个关键字，表示最终的，不可变的</span><br><span class="line">    2. finally也是一个关键字，和try联合使用，使用在异常机制中，finally语句块中的代码是一定会执行的。</span><br><span class="line">    3. finalize()是Object类中的一个方法。作为方法名称出现，所以finalize是一个标识符。</span><br><span class="line"></span><br><span class="line"></span><br></pre></td></tr></table></figure></li></ol>]]></content>
    
    
    <summary type="html">异常</summary>
    
    
    
    <category term="Java" scheme="https://my-zhb.github.io/categories/Java/"/>
    
    <category term="se" scheme="https://my-zhb.github.io/categories/Java/se/"/>
    
    
    <category term="Java基础" scheme="https://my-zhb.github.io/tags/Java%E5%9F%BA%E7%A1%80/"/>
    
  </entry>
  
  <entry>
    <title>内部类</title>
    <link href="https://my-zhb.github.io/2020/12/09/9bc01b38.html"/>
    <id>https://my-zhb.github.io/2020/12/09/9bc01b38.html</id>
    <published>2020-12-09T11:41:33.000Z</published>
    <updated>2020-12-11T12:20:05.822Z</updated>
    
    <content type="html"><![CDATA[<h1 id="什么是内部类"><a href="#什么是内部类" class="headerlink" title="什么是内部类"></a>什么是内部类</h1><p>内部类就是在一个类的内部在定义一个类，比如，A类中定义一个B类，那么B类相对于A类来说就成为内部类，而A类相对B类来说就是外部类。</p><h1 id="内部类分为4种"><a href="#内部类分为4种" class="headerlink" title="内部类分为4种"></a>内部类分为4种</h1><h2 id="成员内部类"><a href="#成员内部类" class="headerlink" title="成员内部类"></a>成员内部类</h2><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Outer</span></span>&#123;</span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">int</span> id;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">out</span><span class="params">()</span></span>&#123;</span><br><span class="line">        System.out.println(<span class="string">&quot;这是外部类&quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="class"><span class="keyword">class</span> <span class="title">Inner</span></span>&#123;</span><br><span class="line">        <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">in</span><span class="params">()</span></span>&#123;</span><br><span class="line">            System.out.println(<span class="string">&quot;这是内部类的方法&quot;</span>);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="comment">//内部类可获取外部的私有属性</span></span><br><span class="line">        <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">getID</span><span class="params">()</span></span>&#123;</span><br><span class="line">            System.out.println(id);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Application</span></span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[]args)</span></span>&#123;</span><br><span class="line">        Outer outer = <span class="keyword">new</span> Outer();</span><br><span class="line">        <span class="comment">//通过外部类实例化内部类</span></span><br><span class="line">        Outer.Inner inner = outer.<span class="function">new <span class="title">Inner</span><span class="params">()</span></span>;</span><br><span class="line">        inner.in();</span><br><span class="line">        inner.getID();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="静态内部类"><a href="#静态内部类" class="headerlink" title="静态内部类"></a>静态内部类</h2><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Outer</span></span>&#123;</span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">int</span> id;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">out</span><span class="params">()</span></span>&#123;</span><br><span class="line">        System.out.println(<span class="string">&quot;这是外部类&quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">static</span> <span class="class"><span class="keyword">class</span> <span class="title">Inner</span></span>&#123;</span><br><span class="line">        <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">in</span><span class="params">()</span></span>&#123;</span><br><span class="line">            System.out.println(<span class="string">&quot;这是内部类的方法&quot;</span>);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="comment">//静态内部类是无法拿到外部类的私有属性的，因为静态的会先被加载</span></span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Application</span></span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[]args)</span></span>&#123;</span><br><span class="line">        Outer.Inner.in();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure><h2 id="局部内部类"><a href="#局部内部类" class="headerlink" title="局部内部类"></a>局部内部类</h2><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Outer</span></span>&#123;</span><br><span class="line">    <span class="comment">//局部内部类</span></span><br><span class="line">    <span class="comment">//在方法里定义的类 就是局部内部类</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">method</span><span class="params">()</span></span>&#123;</span><br><span class="line">        <span class="class"><span class="keyword">class</span> <span class="title">Inner</span></span>&#123;</span><br><span class="line">            </span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="匿名内部类"><a href="#匿名内部类" class="headerlink" title="匿名内部类"></a>匿名内部类</h2><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Outer</span></span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">method</span><span class="params">()</span></span>&#123;</span><br><span class="line">        </span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Application</span></span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[]args)</span></span>&#123;</span><br><span class="line">        <span class="comment">//没有名字初始化类，不用将实例保存到变量中，就是匿名内部类</span></span><br><span class="line">       <span class="keyword">new</span> Outer().method();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>]]></content>
    
    
    <summary type="html">内部类</summary>
    
    
    
    <category term="Java" scheme="https://my-zhb.github.io/categories/Java/"/>
    
    <category term="se" scheme="https://my-zhb.github.io/categories/Java/se/"/>
    
    
    <category term="Java基础" scheme="https://my-zhb.github.io/tags/Java%E5%9F%BA%E7%A1%80/"/>
    
  </entry>
  
  <entry>
    <title>接口</title>
    <link href="https://my-zhb.github.io/2020/12/08/5951da65.html"/>
    <id>https://my-zhb.github.io/2020/12/08/5951da65.html</id>
    <published>2020-12-08T11:05:06.000Z</published>
    <updated>2020-12-14T12:32:59.906Z</updated>
    
    <content type="html"><![CDATA[<h1 id="什么是接口"><a href="#什么是接口" class="headerlink" title="什么是接口"></a>什么是接口</h1><ul><li>普通类：只有具体实现</li><li>抽象类：具体实现和规范(抽象方法)都有！</li><li>接口：只有规范！</li></ul><ol><li>接口就是规范，定义的是一组规则，体现了现实世界中”如果你是…则必须能…”的思想。如果你是天使则必须能飞。</li><li><code>接口的本质是契约</code>，就像我们人类的法律一样。制定好后大家都遵守。</li></ol><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="comment">//定义接口的关键字 interface</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">interface</span> <span class="title">UserService</span></span>&#123;</span><br><span class="line">    </span><br><span class="line">    <span class="comment">//接口里面的方法都是抽象的 public abstract</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">abstract</span> <span class="keyword">void</span> <span class="title">run</span><span class="params">()</span></span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="comment">//类 可以实现接口 通过关键字 implements</span></span><br><span class="line"><span class="comment">//实现接口就不必重写接口里面的方法</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">UserServiceImpl</span> <span class="keyword">implements</span> <span class="title">UserService</span></span>&#123;</span><br><span class="line">    </span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">run</span><span class="params">()</span></span>&#123;</span><br><span class="line">        </span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h1 id="总结"><a href="#总结" class="headerlink" title="==总结=="></a>==<strong>总结</strong>==</h1><ol><li>接口就是一种约束(<code>接口里面只能出现抽象方法和常量</code>)</li><li>接口定义了一些方法，可以让不同的人实现</li><li>接口里面定义的方法都是 public abstract (<code>可以直接忽略不写</code>)</li><li>接口里面定义的常量都是 public static final (<code>可以直接忽略不写</code>)</li><li>接口不能被实例化，接口中没有构造方法。</li><li>implements可以实现多个接口</li><li>类实现了接口就必须重写接口里面的方法。</li><li>接口中的方法都是抽象方法，所以接口里的方法不能有方法体。</li><li>接口可以多继承接口。</li><li>实现接口的类，方法的访问权限不能比接口底。</li><li>接口的使用离不开多态度机制（接口+多态才能达到解耦合）</li></ol><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Test</span></span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[]args)</span></span>&#123;</span><br><span class="line">        <span class="comment">//这里是多态的一种表现</span></span><br><span class="line">        <span class="comment">//抽象类是不能够被实例化的</span></span><br><span class="line">        MyMath my = <span class="keyword">new</span> MyMathImpl();</span><br><span class="line">        my.sum(<span class="number">1</span>,<span class="number">2</span>);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">interface</span> <span class="title">MyMath</span></span>&#123;</span><br><span class="line">    <span class="keyword">double</span> PI = <span class="number">3.1415926</span>;</span><br><span class="line"><span class="comment">//  public static final double PI=3.1415936; 效果一样，可以省略不写 public static final    </span></span><br><span class="line">    <span class="function"><span class="keyword">int</span> <span class="title">sum</span><span class="params">(<span class="keyword">int</span> a,<span class="keyword">int</span> b)</span></span>;</span><br><span class="line"><span class="comment">//  public abstract int sum(int a,int b); 效果与上面的一样 这里public abstract可以省略    </span></span><br><span class="line">    <span class="function"><span class="keyword">int</span> <span class="title">sub</span><span class="params">(<span class="keyword">int</span> a,<span class="keyword">int</span> b)</span></span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">//非抽象类实现了抽象类必须重写方法</span></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">MyMathImpl</span> <span class="keyword">implements</span> <span class="title">MyMath</span></span>&#123;</span><br><span class="line">    </span><br><span class="line">    <span class="function"><span class="keyword">int</span> <span class="title">sum</span><span class="params">(<span class="keyword">int</span> a,<span class="keyword">int</span> b)</span></span>&#123;</span><br><span class="line">        </span><br><span class="line">    &#125;;</span><br><span class="line">    </span><br><span class="line"><span class="comment">/*  这里的访问修饰符不能比抽象类方法的访问修饰符权限低 只能比它高  </span></span><br><span class="line"><span class="comment">    private int sum(int a,int b)&#123;</span></span><br><span class="line"><span class="comment">        </span></span><br><span class="line"><span class="comment">    &#125;;</span></span><br><span class="line"><span class="comment">*/</span>    </span><br><span class="line">    <span class="function"><span class="keyword">int</span> <span class="title">sub</span><span class="params">(<span class="keyword">int</span> a,<span class="keyword">int</span> b)</span></span>&#123;</span><br><span class="line">        </span><br><span class="line">    &#125;;</span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure><h1 id="抽象类和接口有什么区别？"><a href="#抽象类和接口有什么区别？" class="headerlink" title="抽象类和接口有什么区别？"></a>抽象类和接口有什么区别？</h1><ol><li>抽象类是半抽象的，接口是完全抽象的。</li><li>抽象类中有构造方法，接口中没有构造方法。</li><li>接口和接口之间支持多继承，类和类之间只能单集成。</li><li>一个类可以同时实现多个接口，一个抽象类只能继承一个类（单继承）。</li><li>接口中只允许出现常量和抽象方法。</li></ol>]]></content>
    
    
    <summary type="html">接口</summary>
    
    
    
    <category term="Java" scheme="https://my-zhb.github.io/categories/Java/"/>
    
    <category term="se" scheme="https://my-zhb.github.io/categories/Java/se/"/>
    
    
    <category term="Java基础" scheme="https://my-zhb.github.io/tags/Java%E5%9F%BA%E7%A1%80/"/>
    
  </entry>
  
  <entry>
    <title>类与对象的关系</title>
    <link href="https://my-zhb.github.io/2020/12/08/d1212574.html"/>
    <id>https://my-zhb.github.io/2020/12/08/d1212574.html</id>
    <published>2020-12-08T11:03:26.000Z</published>
    <updated>2020-12-11T12:19:57.685Z</updated>
    
    <content type="html"><![CDATA[<h1 id="什么是类？"><a href="#什么是类？" class="headerlink" title="什么是类？"></a>什么是类？</h1><p><code>类是一种抽象的数据类型，它是对某一类事物整体描述/定义，但是并不能代表每一个具体的事物</code></p><h1 id="什么是对象？"><a href="#什么是对象？" class="headerlink" title="什么是对象？"></a>什么是对象？</h1><p><code>对象是抽象概念的具体实例</code></p><h2 id="创建与初始化对象"><a href="#创建与初始化对象" class="headerlink" title="创建与初始化对象"></a>创建与初始化对象</h2><ul><li><code>使用new关键字创建对象</code></li><li>使用new关键字创建的时候，除了分配内存空间之外，还会给创建好的对象进行默认初始化以及对类中构造器的调用。</li><li>类中的构造器也被称为构造方法，是在进行创建对象的时候必须要调用的。并且构造器有以下两个特点  <ol><li>必须和类的名称相同</li><li>必须没有返回类型，也不能写void</li></ol></li></ul><p>重点：<code>类里面定义了有参构造器就必须定义一个无参构造器</code></p>]]></content>
    
    
    <summary type="html">类与对象的关系</summary>
    
    
    
    <category term="Java" scheme="https://my-zhb.github.io/categories/Java/"/>
    
    <category term="se" scheme="https://my-zhb.github.io/categories/Java/se/"/>
    
    
    <category term="Java基础" scheme="https://my-zhb.github.io/tags/Java%E5%9F%BA%E7%A1%80/"/>
    
  </entry>
  
  <entry>
    <title>抽象类</title>
    <link href="https://my-zhb.github.io/2020/12/07/3dbae4e.html"/>
    <id>https://my-zhb.github.io/2020/12/07/3dbae4e.html</id>
    <published>2020-12-07T11:48:07.000Z</published>
    <updated>2020-12-11T12:19:46.843Z</updated>
    
    <content type="html"><![CDATA[<h1 id="什么是抽象类"><a href="#什么是抽象类" class="headerlink" title="什么是抽象类"></a>什么是抽象类</h1><ol><li>abstract修饰符可以用来修饰方法也可以修饰类，如果修饰方法，那么该方法就是抽象方法，如果修饰类那么该类就是抽象。</li><li>抽象类中可以没有抽象方法，但是有抽象方法的类一定要声明为抽象类。</li><li>抽象类，不能使用new关键字来创建对象，它是用来让子类继承的。</li><li>抽象方法，只有方法的声明，没有方法的实现，它是用来让子类实现的。</li><li>子类继承抽象类，那么就必须要实现抽象类没有实现的抽象方法，否则该子类也要声明为抽象类。</li><li>抽象类里面可以写普通方法。</li></ol><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="comment">//abstract 抽象类</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">abstract</span> <span class="class"><span class="keyword">class</span> <span class="title">Action</span></span>&#123;</span><br><span class="line">    </span><br><span class="line">    <span class="comment">//约束·有人帮忙实现</span></span><br><span class="line">    <span class="comment">//abstract 抽象方法，只有 方法名称 没有方法实现</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">abstract</span> <span class="keyword">void</span> <span class="title">doSomething</span><span class="params">()</span></span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="comment">//抽象类的方法必须要有继承它的子类去实现</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">A</span> <span class="keyword">extends</span> <span class="title">Action</span></span>&#123;</span><br><span class="line">    </span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">doSomething</span><span class="params">()</span></span>&#123;</span><br><span class="line">        </span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h1 id="抽象类的特点"><a href="#抽象类的特点" class="headerlink" title="抽象类的特点"></a>抽象类的特点</h1><ol><li>抽象类不能new出来，只能靠子类去实现它，是一种约束!</li><li>抽象类中可以写普通的方法。</li><li>抽象方法必须在抽象类中。</li><li>抽象类也是属于引用数据类型。</li><li>抽象类的子类也可以是抽象类。</li></ol><h1 id="问题"><a href="#问题" class="headerlink" title="问题"></a>问题</h1><ol><li>抽象类里面有构造方法吗？<br>有</li></ol><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="comment">//</span></span><br><span class="line"><span class="comment">// Source code recreated from a .class file by IntelliJ IDEA</span></span><br><span class="line"><span class="comment">// (powered by Fernflower decompiler)</span></span><br><span class="line"><span class="comment">//</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">abstract</span> <span class="class"><span class="keyword">class</span> <span class="title">Test</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="title">Test</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">abstract</span> <span class="keyword">void</span> <span class="title">s</span><span class="params">()</span></span>;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">run</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        System.out.println(<span class="string">&quot;1&quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure>]]></content>
    
    
    <summary type="html">抽象类</summary>
    
    
    
    <category term="Java" scheme="https://my-zhb.github.io/categories/Java/"/>
    
    <category term="se" scheme="https://my-zhb.github.io/categories/Java/se/"/>
    
    
    <category term="Java基础" scheme="https://my-zhb.github.io/tags/Java%E5%9F%BA%E7%A1%80/"/>
    
  </entry>
  
  <entry>
    <title>static关键字</title>
    <link href="https://my-zhb.github.io/2020/12/06/ce244871.html"/>
    <id>https://my-zhb.github.io/2020/12/06/ce244871.html</id>
    <published>2020-12-06T12:12:53.000Z</published>
    <updated>2020-12-11T12:20:34.301Z</updated>
    
    <content type="html"><![CDATA[<h1 id="类加载"><a href="#类加载" class="headerlink" title="类加载"></a>类加载</h1><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Test</span></span>&#123;</span><br><span class="line">    &#123;</span><br><span class="line">        System.out.println(<span class="string">&quot;匿名代码块&quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">static</span>&#123;</span><br><span class="line">        System.out.println(<span class="string">&quot;静态代码块&quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="title">Test</span><span class="params">()</span></span>&#123;</span><br><span class="line">        System.out.println(<span class="string">&quot;构造方法&quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] ages)</span></span>&#123;</span><br><span class="line">        Test test = <span class="keyword">new</span> Test();</span><br><span class="line">        System.out.println(<span class="string">&quot;===============&quot;</span>);</span><br><span class="line">        Test test = <span class="keyword">new</span> Test();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure><p>输出结果:</p><figure class="highlight java"><table><tr><td class="code"><pre><span class="line">静态代码块</span><br><span class="line">匿名代码块</span><br><span class="line">构造方法</span><br><span class="line">===============</span><br><span class="line">匿名代码块</span><br><span class="line">构造方法</span><br></pre></td></tr></table></figure><p>总结：</p><ol><li>第一次执行先执行静态代码块 在执行匿名代码块 最后执行构造方法</li><li>静态方法只执行一次</li></ol><h1 id="静态导入包"><a href="#静态导入包" class="headerlink" title="静态导入包"></a>静态导入包</h1><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="comment">//静态导入包</span></span><br><span class="line"><span class="keyword">import</span> <span class="keyword">static</span> java.<span class="keyword">long</span>.Math.random;</span><br><span class="line"><span class="keyword">import</span> <span class="keyword">static</span> java.<span class="keyword">long</span>.Math.PI;</span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Test</span></span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] ages)</span></span>&#123;</span><br><span class="line">        System.out.println(random());</span><br><span class="line">        System.out.println(PI);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h1 id="静态属性及方法"><a href="#静态属性及方法" class="headerlink" title="静态属性及方法"></a>静态属性及方法</h1><p>静态的属性和方法可以直接通过类名调用</p>]]></content>
    
    
    <summary type="html">static关键字</summary>
    
    
    
    <category term="Java" scheme="https://my-zhb.github.io/categories/Java/"/>
    
    <category term="se" scheme="https://my-zhb.github.io/categories/Java/se/"/>
    
    
    <category term="Java基础" scheme="https://my-zhb.github.io/tags/Java%E5%9F%BA%E7%A1%80/"/>
    
  </entry>
  
  <entry>
    <title>面向对象的3大特征</title>
    <link href="https://my-zhb.github.io/2020/12/05/7867351e.html"/>
    <id>https://my-zhb.github.io/2020/12/05/7867351e.html</id>
    <published>2020-12-05T09:01:36.000Z</published>
    <updated>2020-12-11T12:20:00.502Z</updated>
    
    <content type="html"><![CDATA[<h1 id="封装"><a href="#封装" class="headerlink" title="封装"></a>封装</h1><ol><li><p>该露的露，该藏的藏</p><p> 我们程序设计追求<code>高内聚，低耦合</code>。高内聚就是类的内部数据操作细节自己完成，不允许外部干涉；低耦合：仅量暴露少量的方法给我外部使用</p></li><li><p>封装（数据的隐藏）</p><p> 通常，应静止直接访问一个对象中的实际表示，而应通过操作接口来访问，这称为信息隐藏。</p></li></ol><p><code>记住这句话就够了：属性私有，get/set</code></p><p><code>封装的核心private私有化</code></p><h2 id="封装的意义"><a href="#封装的意义" class="headerlink" title="封装的意义"></a>封装的意义</h2><ol><li>提高程序的安全性，保护数据</li><li>隐藏代码的实现细节</li><li>统一接口</li><li>系统可维护性增加</li></ol><h1 id="继承"><a href="#继承" class="headerlink" title="继承"></a>继承</h1><ol><li>继承的本质是对某一批类的抽象，从而实现对现实世界更好的建模。</li><li><code>extends</code>的意思是”扩展”。子类是分类的扩展。</li><li><code>Java中类只有单继承，没有多继承！</code></li><li>继承是类和类之间的一种关系。除此之外，类和类之间的关系还有依赖、组合、聚合等。</li><li>继承关系的两个类，一个为子类（派生类），一个为父类（基类）。子类继承父类，使用关键字extends来表示。</li><li>子类和父类之间，从意义上讲应该具有”is a”的关系。  </li></ol><p>重点：</p><ul><li>object类  </li><li>super  </li><li>方法重写 </li></ul><h2 id="继承注意"><a href="#继承注意" class="headerlink" title="继承注意"></a>继承注意</h2><ol><li><p>super注意点：</p><ul><li>super调用父类的构造方法，必须在构造方法的第一个</li><li>super必须只能出现在子类的构造方法中！</li><li>super和this不能同时调用构造方法！</li></ul></li><li><p>this</p><ol><li>代表的不同对象：<ul><li>this:本身调用者这个对象</li><li>super：代表父类对象的引用</li></ul></li><li>前提<ul><li>this：没有继承也可以使用</li><li>super：只能在继承条件才可以使用</li></ul></li><li>构造方法<ul><li>this() 本类的构造</li><li>super() 父类的构造</li></ul></li></ol></li></ol><h2 id="方法重写"><a href="#方法重写" class="headerlink" title="方法重写"></a>方法重写</h2><ol><li>重写都是方法的重写，和属性无关</li><li>构造方法不能被继承，所以构造方法也不能被重写。</li></ol><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="comment">//父类</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">A</span></span>&#123; </span><br><span class="line">    <span class="comment">//静态方法</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">test</span><span class="params">()</span></span>&#123;</span><br><span class="line">        System.out.println(<span class="string">&quot;A==&gt;test()&quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">     <span class="comment">//非静态方法</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">test1</span><span class="params">()</span></span>&#123;</span><br><span class="line">        System.out.println(<span class="string">&quot;test1==&gt;A==&gt;test()&quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="comment">//子类</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">B</span> <span class="keyword">extends</span> <span class="title">A</span></span>&#123;</span><br><span class="line">    <span class="comment">//静态方法</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">test</span><span class="params">()</span></span>&#123;</span><br><span class="line">        System.out.println(<span class="string">&quot;B==&gt;test()&quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    <span class="comment">//非静态方法</span></span><br><span class="line">    <span class="comment">//Override 重写</span></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">test1</span><span class="params">()</span></span>&#123;</span><br><span class="line">        System.out.println(<span class="string">&quot;test2==&gt;B==&gt;test()&quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="comment">//测试</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Test</span></span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[]args)</span></span>&#123;</span><br><span class="line">        <span class="comment">//方法的调用只和左边定义的数据类型有关</span></span><br><span class="line">        B b = <span class="keyword">new</span> B();</span><br><span class="line">        </span><br><span class="line">        <span class="comment">//父类的引用指向了子类</span></span><br><span class="line">        B b = <span class="keyword">new</span> A();<span class="comment">//非静态下子类重写了父类的方法</span></span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="comment">//静态方法输出结果</span></span><br><span class="line">B==&gt;test()</span><br><span class="line">A==&gt;test()</span><br><span class="line"></span><br><span class="line"><span class="comment">//非静态方法输出结果</span></span><br><span class="line">test2==&gt;B==&gt;test()</span><br><span class="line">test2==&gt;B==&gt;test()</span><br></pre></td></tr></table></figure><h2 id="重写注意"><a href="#重写注意" class="headerlink" title="重写注意"></a>重写注意</h2><ol><li>需要有继承关系，子类重写父类的方法！</li><li>方法名必须相同</li><li>参数列表必须相同</li><li>修饰符：范围可以扩大但不能缩小，public&gt;Protected&gt;Default&gt;private</li><li>抛出的异常：<ul><li>编译时异常：范围可以缩小，但不能扩大。ClassNotFoundException–&gt;Exception(大)</li><li>运行时异常：可以直接抛出！</li></ul></li><li>重写，子类的方法和父类必须要一致，方法体不同！</li><li>只要子类重写了父类的方法一定走的是子类的方法。  </li><li>方法覆盖只是针对方法，和属性无关。</li><li>私有方法无法被覆盖</li><li>方法重写只针对实例方法。  </li><li>为什么需要重写：<ul><li>父类的功能，子类不一定需要，或者不一定满足！</li></ul></li></ol><h1 id="多态"><a href="#多态" class="headerlink" title="多态"></a>多态</h1><ol><li>动态编译：类型：可扩展性</li><li>即同一方法可以根据发送对象的不同而采用多种不同的行为方式。</li><li>一个对象的实现类型是确定的，但可以只想对象的引用的类型很多。</li><li>多态存在的条件<ul><li>有继承关系</li><li>子类重写父类方法</li><li>父类引用指向子类对象</li></ul></li></ol><h2 id="多态注意"><a href="#多态注意" class="headerlink" title="多态注意"></a>多态注意</h2><ol><li>多态是方法的多态，属性没有多态性</li><li>父类和子类，有联系 类型转换异常！ ClassCastException!</li><li>存在条件：继承关系，方法需要重写，父类引用指向子类对象！ Father f1 = new Son();<ul><li>但有些方法是不能被重写的！<ul><li>static 方法，属于类，它不属于实例；</li><li>final 常量；</li><li>private 方法；</li></ul></li></ul></li></ol><h2 id="instanceof"><a href="#instanceof" class="headerlink" title="instanceof"></a><code>instanceof</code></h2><p>严格来说是Java中的一个双目运算符，用来测试一个对象是否为一个类的实例 </p><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Person</span></span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">run</span><span class="params">()</span></span>&#123;</span><br><span class="line">        System.out.println(<span class="string">&quot;run&quot;</span>);   </span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Student</span> <span class="keyword">extends</span> <span class="title">Person</span></span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">go</span><span class="params">()</span></span>&#123;</span><br><span class="line">        System.out.println(<span class="string">&quot;go&quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Teacher</span> <span class="keyword">extends</span> <span class="title">Person</span></span>&#123;</span><br><span class="line">    </span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Test</span></span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[]args)</span></span>&#123;</span><br><span class="line">        <span class="comment">//Object &gt; String</span></span><br><span class="line">        <span class="comment">//Object &gt; Person &gt; Teacher</span></span><br><span class="line">        <span class="comment">//Object &gt; Person &gt; Student</span></span><br><span class="line">        Object object = <span class="keyword">new</span> Student();</span><br><span class="line">        System.out.println(object <span class="keyword">instanceof</span> Student);<span class="comment">//true</span></span><br><span class="line">        System.out.println(object <span class="keyword">instanceof</span> Person);<span class="comment">//true</span></span><br><span class="line">        System.out.println(object <span class="keyword">instanceof</span> Object);<span class="comment">//true</span></span><br><span class="line">        System.out.println(object <span class="keyword">instanceof</span> Teacher);<span class="comment">//false</span></span><br><span class="line">        System.out.println(object <span class="keyword">instanceof</span> String);<span class="comment">//false</span></span><br><span class="line">        </span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><code>总结</code><br>X instanceof Y 如果没有父子关系编译直接报错。</p><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Test</span></span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[]args)</span></span>&#123;</span><br><span class="line">        <span class="comment">//类型之间的转换</span></span><br><span class="line">        <span class="comment">//高                低</span></span><br><span class="line">        Person obj = <span class="keyword">new</span> Student();</span><br><span class="line">        </span><br><span class="line">        <span class="comment">//obj，我们就可以使用Student类型的方法</span></span><br><span class="line">        <span class="comment">//高转低 需要强制转换</span></span><br><span class="line">        <span class="comment">//子类转父类(低转高) 可能会丢失自己本身的一些方法</span></span><br><span class="line">        Student student=(Student)obj;</span><br><span class="line">        student.go();</span><br><span class="line">        </span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="多态总结"><a href="#多态总结" class="headerlink" title="多态总结"></a>多态总结</h2><ol><li>父类引用指向子类的对象。</li><li>把子类转换成父类，向上转型。</li><li>把父类转成子类，向下转型，强制转换。</li><li>方便方法的调用，减少重复的代码。</li></ol>]]></content>
    
    
    <summary type="html">面向对象的3大特征</summary>
    
    
    
    <category term="Java" scheme="https://my-zhb.github.io/categories/Java/"/>
    
    <category term="se" scheme="https://my-zhb.github.io/categories/Java/se/"/>
    
    
    <category term="Java基础" scheme="https://my-zhb.github.io/tags/Java%E5%9F%BA%E7%A1%80/"/>
    
  </entry>
  
  <entry>
    <title>什么是面向过程、面向对象</title>
    <link href="https://my-zhb.github.io/2020/12/04/c5d97b3b.html"/>
    <id>https://my-zhb.github.io/2020/12/04/c5d97b3b.html</id>
    <published>2020-12-04T12:13:01.000Z</published>
    <updated>2020-12-11T12:20:11.973Z</updated>
    
    <content type="html"><![CDATA[<h1 id="面向过程思想"><a href="#面向过程思想" class="headerlink" title="面向过程思想"></a>面向过程思想</h1><ol><li><p>步骤清晰简单，第一步做什么，第二步做什么。</p></li><li><p>面对过程适合处理一些较为简单的问题。</p></li><li><p>面向过程都是有因果关系的，比如，因为A所以才有B….</p></li></ol><p><code>面向过程的缺点：高耦合,可扩展性差，一步错步步错。</code></p><p><code>面向过程的优点：对于小型项目，效率较高，不用抽取对象，可直接编码。</code></p><h1 id="什么是OOA、OOD、OOP"><a href="#什么是OOA、OOD、OOP" class="headerlink" title="什么是OOA、OOD、OOP"></a>什么是OOA、OOD、OOP</h1><ol><li>OOA 面向对象分析</li><li>OOD 面向对象设计</li><li>OOP 面向对象编码</li></ol><h1 id="面向对象思想"><a href="#面向对象思想" class="headerlink" title="面向对象思想"></a>面向对象思想</h1><ol><li><p>物以类聚，分类的思维模式，思考问题首先会解决问题需要哪些分类，然后对这些分类进行单独思考。最后才对某个分类下的细节进行面向过程的思考。</p></li><li><p>面向对象适合处理复杂的问题，适合处理需要多人协作的问题!</p></li><li><p><code>对于描述复杂的事物，为了从宏观上把握、从整体上合理分析，我们需要使用面向对象的思路来分析整个系统。但是，具体到微观操作，仍然需要面向过程的思路去处理。</code></p></li></ol><h1 id="什么是面向对象"><a href="#什么是面向对象" class="headerlink" title="什么是面向对象"></a>什么是面向对象</h1><ol><li><p>面向对象编程的本质就是：<code>以类的方式组织代码，以对象的组织（封装）数据</code></p></li><li><p>抽象（抽象就是抽取事物的相同点）</p></li><li><p>封装（封装可以被认为是一个保护屏障，防止该类的代码和数据被外部类定义的代码随机访问。要访问该类的代码和数据，必须通过严格的接口控制）</p><ul><li><p>良好的封装能够减少耦合。</p></li><li><p>类内部的结构可以自由修改。</p></li><li><p>可以对成员变量进行更精确的控制。</p></li><li><p>隐藏信息，实现细节。 </p></li></ul></li><li><p>继承</p></li><li><p>多态（一种事物有多种形态）</p></li><li><p>从认识论角度考虑是先有对象后有类。对象，是具体的事物。类，是抽象的，是对对象的抽象。</p></li><li><p>从代码运行角度考虑是先有类后有对象。类是对象的模板。</p></li></ol>]]></content>
    
    
    <summary type="html">什么是面向过程、面向对象</summary>
    
    
    
    <category term="Java" scheme="https://my-zhb.github.io/categories/Java/"/>
    
    <category term="se" scheme="https://my-zhb.github.io/categories/Java/se/"/>
    
    
    <category term="Java基础" scheme="https://my-zhb.github.io/tags/Java%E5%9F%BA%E7%A1%80/"/>
    
  </entry>
  
  <entry>
    <title>稀疏数组</title>
    <link href="https://my-zhb.github.io/2020/12/03/a6455d41.html"/>
    <id>https://my-zhb.github.io/2020/12/03/a6455d41.html</id>
    <published>2020-12-03T12:29:50.000Z</published>
    <updated>2020-12-11T12:20:17.252Z</updated>
    
    <content type="html"><![CDATA[<h1 id="什么是稀疏数组？"><a href="#什么是稀疏数组？" class="headerlink" title="什么是稀疏数组？"></a>什么是稀疏数组？</h1><ol><li>当一个数组中大步幅元素为0，或者为同一个值的数组是，可以使用稀疏数组来保持该数组。</li><li>稀疏数组的处理方式<ul><li>记录数组一共有几行几列，有多少个不同值</li><li>把具有不同值的元素和行列及值记录在一个小规模的数组中，从而缩小程序的规模</li></ul></li></ol><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Test</span></span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span></span>&#123;</span><br><span class="line">        <span class="keyword">int</span>[][] array = <span class="keyword">new</span> <span class="keyword">int</span>[<span class="number">11</span>][<span class="number">10</span>];</span><br><span class="line">array[<span class="number">1</span>][<span class="number">2</span>] = <span class="number">1</span>;</span><br><span class="line">array[<span class="number">3</span>][<span class="number">4</span>] = <span class="number">5</span>;</span><br><span class="line">System.err.println(<span class="string">&quot;输出棋盘:&quot;</span>);</span><br><span class="line">Thread.sleep(<span class="number">1000</span>);</span><br><span class="line"><span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; array.length; i++) &#123;</span><br><span class="line"><span class="keyword">for</span> (<span class="keyword">int</span> j = <span class="number">0</span>; j &lt; array[i].length; j++) &#123;</span><br><span class="line">System.out.print(array[i][j]+<span class="string">&quot;\t&quot;</span>);</span><br><span class="line">&#125;</span><br><span class="line">System.out.println();</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">int</span> count = <span class="number">0</span>;</span><br><span class="line"><span class="comment">//获取有效数据</span></span><br><span class="line"><span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; array.length; i++) &#123;</span><br><span class="line"><span class="keyword">for</span> (<span class="keyword">int</span> j = <span class="number">0</span>; j &lt; array[i].length; j++) &#123;</span><br><span class="line"><span class="keyword">if</span>(array[i][j]!=<span class="number">0</span>)&#123;</span><br><span class="line">count = ++count;</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">int</span>[][] num = <span class="keyword">new</span> <span class="keyword">int</span>[count+<span class="number">1</span>][<span class="number">3</span>];</span><br><span class="line"><span class="comment">//获取总共有多少行</span></span><br><span class="line">num[<span class="number">0</span>][<span class="number">0</span>] = array.length;</span><br><span class="line"><span class="comment">//获取总共有多少列</span></span><br><span class="line">num[<span class="number">0</span>][<span class="number">1</span>] = array[<span class="number">0</span>].length;</span><br><span class="line"><span class="comment">//赋值有效数据</span></span><br><span class="line">num[<span class="number">0</span>][<span class="number">2</span>] = count;</span><br><span class="line"><span class="keyword">int</span> number = <span class="number">1</span>;</span><br><span class="line"><span class="comment">//获取稀疏数组</span></span><br><span class="line"><span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; array.length; i++) &#123;</span><br><span class="line"><span class="keyword">for</span> (<span class="keyword">int</span> j = <span class="number">0</span>; j &lt; array[i].length; j++) &#123;</span><br><span class="line"><span class="keyword">if</span>(array[i][j]!=<span class="number">0</span>)&#123;</span><br><span class="line">num[number][<span class="number">0</span>] = i;</span><br><span class="line">num[number][<span class="number">1</span>] = j;</span><br><span class="line">num[number][<span class="number">2</span>] = array[i][j];</span><br><span class="line">number++;</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">System.err.println(<span class="string">&quot;转换后的结果:&quot;</span>);</span><br><span class="line">Thread.sleep(<span class="number">1000</span>);</span><br><span class="line"><span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; num.length; i++) &#123;</span><br><span class="line"><span class="keyword">for</span> (<span class="keyword">int</span> j = <span class="number">0</span>; j &lt; num[i].length; j++) &#123;</span><br><span class="line">System.out.print(num[i][j]+<span class="string">&quot;\t&quot;</span>);</span><br><span class="line">&#125;</span><br><span class="line">System.out.println();</span><br><span class="line">&#125;</span><br><span class="line">        <span class="comment">//取出稀疏数组的行列</span></span><br><span class="line"><span class="keyword">int</span>[][] nums = <span class="keyword">new</span> <span class="keyword">int</span>[num[<span class="number">0</span>][<span class="number">0</span>]][num[<span class="number">0</span>][<span class="number">1</span>]];</span><br><span class="line">System.err.println(<span class="string">&quot;还原稀疏数组:&quot;</span>);</span><br><span class="line">Thread.sleep(<span class="number">1000</span>);</span><br><span class="line">    </span><br><span class="line">        <span class="comment">//渲染稀疏数组有效值从第一行开始渲染</span></span><br><span class="line"><span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">1</span>; i &lt; num.length; i++) &#123;</span><br><span class="line">nums[num[i][<span class="number">0</span>]][num[i][<span class="number">1</span>]] = num[i][<span class="number">2</span>];</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; nums.length; i++) &#123;</span><br><span class="line"><span class="keyword">for</span> (<span class="keyword">int</span> j = <span class="number">0</span>; j &lt; nums[i].length; j++) &#123;</span><br><span class="line">System.out.print(nums[i][j]+<span class="string">&quot;\t&quot;</span>);</span><br><span class="line">&#125;</span><br><span class="line">System.out.println();</span><br><span class="line">&#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>结果：</p><figure class="highlight java"><table><tr><td class="code"><pre><span class="line">输出棋盘:</span><br><span class="line"><span class="number">0</span><span class="number">0</span><span class="number">0</span><span class="number">0</span><span class="number">0</span><span class="number">0</span><span class="number">0</span><span class="number">0</span><span class="number">0</span><span class="number">0</span></span><br><span class="line"><span class="number">0</span><span class="number">0</span><span class="number">1</span><span class="number">0</span><span class="number">0</span><span class="number">0</span><span class="number">0</span><span class="number">0</span><span class="number">0</span><span class="number">0</span></span><br><span class="line"><span class="number">0</span><span class="number">0</span><span class="number">0</span><span class="number">0</span><span class="number">0</span><span class="number">0</span><span class="number">0</span><span class="number">0</span><span class="number">0</span><span class="number">0</span></span><br><span class="line"><span class="number">0</span><span class="number">0</span><span class="number">0</span><span class="number">0</span><span class="number">5</span><span class="number">0</span><span class="number">0</span><span class="number">0</span><span class="number">0</span><span class="number">0</span></span><br><span class="line"><span class="number">0</span><span class="number">0</span><span class="number">0</span><span class="number">0</span><span class="number">0</span><span class="number">0</span><span class="number">0</span><span class="number">0</span><span class="number">0</span><span class="number">0</span></span><br><span class="line"><span class="number">0</span><span class="number">0</span><span class="number">0</span><span class="number">0</span><span class="number">0</span><span class="number">0</span><span class="number">0</span><span class="number">0</span><span class="number">0</span><span class="number">0</span></span><br><span class="line"><span class="number">0</span><span class="number">0</span><span class="number">0</span><span class="number">0</span><span class="number">0</span><span class="number">0</span><span class="number">0</span><span class="number">0</span><span class="number">0</span><span class="number">0</span></span><br><span class="line"><span class="number">0</span><span class="number">0</span><span class="number">0</span><span class="number">0</span><span class="number">0</span><span class="number">0</span><span class="number">0</span><span class="number">0</span><span class="number">0</span><span class="number">0</span></span><br><span class="line"><span class="number">0</span><span class="number">0</span><span class="number">0</span><span class="number">0</span><span class="number">0</span><span class="number">0</span><span class="number">0</span><span class="number">0</span><span class="number">0</span><span class="number">0</span></span><br><span class="line"><span class="number">0</span><span class="number">0</span><span class="number">0</span><span class="number">0</span><span class="number">0</span><span class="number">0</span><span class="number">0</span><span class="number">0</span><span class="number">0</span><span class="number">0</span></span><br><span class="line"><span class="number">0</span><span class="number">0</span><span class="number">0</span><span class="number">0</span><span class="number">0</span><span class="number">0</span><span class="number">0</span><span class="number">0</span><span class="number">0</span><span class="number">0</span></span><br><span class="line">转换后的结果:</span><br><span class="line">列  行  值</span><br><span class="line"><span class="number">11</span><span class="number">10</span><span class="number">2</span>   <span class="comment">//第一行表示一共有11行10列有效值为2个</span></span><br><span class="line"><span class="number">1</span><span class="number">2</span><span class="number">1</span>   <span class="comment">//第二行表示第一个值在第1行第2列值是1</span></span><br><span class="line"><span class="number">3</span><span class="number">4</span><span class="number">5</span>   <span class="comment">//第三行表示第二个值在第3行第4列值是5，以此类推</span></span><br><span class="line">还原稀疏数组:</span><br><span class="line"><span class="number">0</span><span class="number">0</span><span class="number">0</span><span class="number">0</span><span class="number">0</span><span class="number">0</span><span class="number">0</span><span class="number">0</span><span class="number">0</span><span class="number">0</span></span><br><span class="line"><span class="number">0</span><span class="number">0</span><span class="number">1</span><span class="number">0</span><span class="number">0</span><span class="number">0</span><span class="number">0</span><span class="number">0</span><span class="number">0</span><span class="number">0</span></span><br><span class="line"><span class="number">0</span><span class="number">0</span><span class="number">0</span><span class="number">0</span><span class="number">0</span><span class="number">0</span><span class="number">0</span><span class="number">0</span><span class="number">0</span><span class="number">0</span></span><br><span class="line"><span class="number">0</span><span class="number">0</span><span class="number">0</span><span class="number">0</span><span class="number">5</span><span class="number">0</span><span class="number">0</span><span class="number">0</span><span class="number">0</span><span class="number">0</span></span><br><span class="line"><span class="number">0</span><span class="number">0</span><span class="number">0</span><span class="number">0</span><span class="number">0</span><span class="number">0</span><span class="number">0</span><span class="number">0</span><span class="number">0</span><span class="number">0</span></span><br><span class="line"><span class="number">0</span><span class="number">0</span><span class="number">0</span><span class="number">0</span><span class="number">0</span><span class="number">0</span><span class="number">0</span><span class="number">0</span><span class="number">0</span><span class="number">0</span></span><br><span class="line"><span class="number">0</span><span class="number">0</span><span class="number">0</span><span class="number">0</span><span class="number">0</span><span class="number">0</span><span class="number">0</span><span class="number">0</span><span class="number">0</span><span class="number">0</span></span><br><span class="line"><span class="number">0</span><span class="number">0</span><span class="number">0</span><span class="number">0</span><span class="number">0</span><span class="number">0</span><span class="number">0</span><span class="number">0</span><span class="number">0</span><span class="number">0</span></span><br><span class="line"><span class="number">0</span><span class="number">0</span><span class="number">0</span><span class="number">0</span><span class="number">0</span><span class="number">0</span><span class="number">0</span><span class="number">0</span><span class="number">0</span><span class="number">0</span></span><br><span class="line"><span class="number">0</span><span class="number">0</span><span class="number">0</span><span class="number">0</span><span class="number">0</span><span class="number">0</span><span class="number">0</span><span class="number">0</span><span class="number">0</span><span class="number">0</span></span><br><span class="line"><span class="number">0</span><span class="number">0</span><span class="number">0</span><span class="number">0</span><span class="number">0</span><span class="number">0</span><span class="number">0</span><span class="number">0</span><span class="number">0</span><span class="number">0</span></span><br></pre></td></tr></table></figure>]]></content>
    
    
    <summary type="html">稀疏数组</summary>
    
    
    
    <category term="Java" scheme="https://my-zhb.github.io/categories/Java/"/>
    
    <category term="se" scheme="https://my-zhb.github.io/categories/Java/se/"/>
    
    
    <category term="Java基础" scheme="https://my-zhb.github.io/tags/Java%E5%9F%BA%E7%A1%80/"/>
    
  </entry>
  
  <entry>
    <title>数组及多维数组</title>
    <link href="https://my-zhb.github.io/2020/12/02/4cb979a2.html"/>
    <id>https://my-zhb.github.io/2020/12/02/4cb979a2.html</id>
    <published>2020-12-02T12:13:24.000Z</published>
    <updated>2020-12-11T12:20:14.926Z</updated>
    
    <content type="html"><![CDATA[<h1 id="数组的定义"><a href="#数组的定义" class="headerlink" title="数组的定义"></a>数组的定义</h1><ol><li>数组时相同类型数据的有序集合。</li><li>数据描述的时相同类型的若干个数据，按照一定的先后次序排列组合而成。</li><li>其中，每一个数据称作一个数组元素，每个数组元素可以通过一个下标来访问它们。</li></ol><h1 id="数组的4个基本特点"><a href="#数组的4个基本特点" class="headerlink" title="数组的4个基本特点"></a>数组的4个基本特点</h1><ol><li>其长度是确定的。数组一旦被创建，它的大小就是不可以改变的。</li><li>其元素必须是相同类型，不允许出现混合类型。</li><li>数组中的元素可以是任何数据类型，包括旗本类型和引用类型。</li><li><code>数组变量属引用类型</code>，数组也可以看成对象，数组中的每个元素相当于对象的成员变量。数组本身就是对象，Java中对象是在推中的，因此数组无论保存原始类型还是其他对象类型，<code>数组对象本身就是堆中的</code></li><li>数组在内存方面存储的时候，数组中的元素内存地址是连续的。</li></ol><h1 id="数组这种数据结构的优点和缺点"><a href="#数组这种数据结构的优点和缺点" class="headerlink" title="数组这种数据结构的优点和缺点?"></a>数组这种数据结构的优点和缺点?</h1><ol><li>优点 查询/查找/检索某个下标上的元素时效极高，可以说是查询效率最高的一个数据结构。<br>  为什么检索效率高？<ol><li>每一个元素的内存地址在空间存储上是连续的。</li><li>每一个元素类型相同，所以占用空间大小一样。</li><li>知道第一个元素内存地址，知道每一个元素占用空间的大小，又知道下标，所以通过一个数学表达式就可以计算出某个下标元素上元素的内存地址，直接通过内存地址定位元素，所以数组的检索效率是最高的。</li><li><code>数组中存储100个元素或者存储100w个元素，在效率是相同的，因为数组中的元素不是一个个找的，而是通过数学表达式算内存地址直接定位的</code></li></ol></li><li>缺点<ol><li>由于为了保证数组中每个元素的内存地址连续，所以在数组中随机删除和添加的时候，效率较低，因为随机增删元素都会影响后面元素的位移操作（<code>注意：对于数组最后一个元素的增删，是没用效率影响的</code>）。</li><li>数组不能存储大数据量，为什么？<br>因为很难再内存空间上找到一块特别大的连续的内存空间.</li></ol></li></ol><h1 id="数组的3种初始化"><a href="#数组的3种初始化" class="headerlink" title="数组的3种初始化"></a>数组的3种初始化</h1><ol><li>静态初始化</li></ol><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">int</span>[] num = &#123;<span class="number">1</span>,<span class="number">2</span>,<span class="number">3</span>,<span class="number">4</span>,<span class="number">5</span>&#125;;</span><br></pre></td></tr></table></figure><ol start="2"><li>动态初始化</li></ol><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">int</span>[] num = <span class="keyword">new</span> <span class="keyword">int</span>[<span class="number">2</span>];</span><br><span class="line">num[<span class="number">0</span>] = <span class="number">1</span>;</span><br><span class="line">num[<span class="number">1</span>] = <span class="number">2</span>;</span><br><span class="line">num[<span class="number">2</span>] = <span class="number">3</span>;</span><br></pre></td></tr></table></figure><ol start="3"><li>默认初始化<br>数组才被创建的时候，就有默认的值，这个值也就是数组类型的默认值。</li></ol><p><code>备注：变量是放在栈里面的，new出来的是放在堆里面的</code></p><h1 id="数组的扩容"><a href="#数组的扩容" class="headerlink" title="数组的扩容"></a>数组的扩容</h1><p>关于一位数组的扩容。<br>Java中对数组的扩容是: 先新建一个大容量的数组然后将小容量数组中的数据一个个拷贝到大数组中。<br><code>总结:数组扩容效率较低，因为涉及到拷贝的问题，所以尽可能少的进行数组的拷贝 </code><br>可以在创建数组对象的时候预估计以下多长合适，最好预估准确，这要可以减少数组的扩容次数，提高效率</p><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Test</span></span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line">        <span class="comment">//拷贝源（从这个数组中拷贝）</span></span><br><span class="line">        <span class="keyword">int</span>[] src = &#123;<span class="number">1</span>,<span class="number">11</span>,<span class="number">22</span>,<span class="number">3</span>,<span class="number">4</span>&#125;;</span><br><span class="line"></span><br><span class="line">        <span class="comment">//拷贝目标（拷贝到这个目标数组上）</span></span><br><span class="line">        <span class="keyword">int</span>[] dest = <span class="keyword">new</span> <span class="keyword">int</span>[<span class="number">20</span>];</span><br><span class="line"></span><br><span class="line">        <span class="comment">/** 调用jdk System类中的arraycopy方法进行数据的拷贝</span></span><br><span class="line"><span class="comment">         * arraycopy方法对应参数如下</span></span><br><span class="line"><span class="comment">         * src 拷贝源</span></span><br><span class="line"><span class="comment">         * srcPos 拷贝的起始位置</span></span><br><span class="line"><span class="comment">         * dest 拷贝目标</span></span><br><span class="line"><span class="comment">         * destPos 拷贝到目标的起始位置</span></span><br><span class="line"><span class="comment">         * length 拷贝长度</span></span><br><span class="line"><span class="comment">         * **/</span></span><br><span class="line">        System.arraycopy(src,<span class="number">1</span>,dest,<span class="number">3</span>,<span class="number">2</span>);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h1 id="多位数组"><a href="#多位数组" class="headerlink" title="多位数组"></a>多位数组</h1><ul><li>多维数组可以看出是数组的数组，比如二位数组就是一个特殊的一位数组，其每一个元素都是一个一位数组（<a href="https://www.processon.com/view/link/5f49dce26376890e62f836a6/">二位数组图点击查看</a>）</li></ul><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">int</span> a[][] = <span class="keyword">new</span> <span class="keyword">int</span>[<span class="number">2</span>][<span class="number">5</span>]</span><br></pre></td></tr></table></figure><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Test</span></span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span></span>&#123;</span><br><span class="line">        <span class="comment">//arry[3][2]</span></span><br><span class="line">        <span class="comment">/*</span></span><br><span class="line"><span class="comment">            1,2 arry[0]</span></span><br><span class="line"><span class="comment">            3,4 arry[1]</span></span><br><span class="line"><span class="comment">            5,6 arry[2]</span></span><br><span class="line"><span class="comment">        */</span></span><br><span class="line">        <span class="keyword">int</span>[][] arry = &#123;&#123;<span class="number">1</span>,<span class="number">2</span>&#125;,&#123;<span class="number">3</span>,<span class="number">4</span>&#125;,&#123;<span class="number">5</span>,<span class="number">6</span>&#125;&#125;;</span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; arry.length ; i++)&#123;</span><br><span class="line">            <span class="keyword">for</span>(<span class="keyword">int</span> j = <span class="number">0</span>; j &lt; arry[i].length; j++)&#123;</span><br><span class="line">                System.out.println(arry[i][j]);</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>]]></content>
    
    
    <summary type="html">数组及多维数组</summary>
    
    
    
    <category term="Java" scheme="https://my-zhb.github.io/categories/Java/"/>
    
    <category term="se" scheme="https://my-zhb.github.io/categories/Java/se/"/>
    
    
    <category term="Java基础" scheme="https://my-zhb.github.io/tags/Java%E5%9F%BA%E7%A1%80/"/>
    
  </entry>
  
</feed>
